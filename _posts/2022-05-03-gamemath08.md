---
title:  "[게임수학] 8. 아핀 공간(Affine space)"
excerpt: 아핀 변환(Affine transformation), 아핀 결합(Affine combination)

categories: ["Game Math"]
tags:
  # - [math]

toc: true
toc_sticky: true

date: 2022-05-03
last_modified_at: 2022-05-03

sidebar_main: true

---

> 학교 수업과 함께 '이득우의 게임 수학'을 공부하며 정리한 내용들입니다. [책 구매하러 가기!](http://aladin.kr/p/6fBSV)  
> 같은 카테고리의 앞선 글을 모두 읽었다고 가정하고 작성되었습니다.  
> 이해되지 않는 부분이 있다면 한번 읽고 와 보세요! 

## 아핀 공간(Affine space)

지금까지 봤던 벡터 공간에는 사실 하나의 문제가 있습니다. 이동 변환 행렬이 없다는 것이죠. 물론 덧셈을 통한 이동 변환은 가능합니다. 이렇게요.

$$
\begin{bmatrix} x \\ y \end{bmatrix}+\begin{bmatrix} 3 \\ 2 \end{bmatrix}=\begin{bmatrix} x+3 \\ y+2 \end{bmatrix}
$${: .align-center}

그러나 행렬 곱을 통한 이동변환은 불가능합니다. 벡터들이 평행이동하려면 기저벡터도 같이 이동해야 하는데, 공간의 크기를 유지하기 위해서는 기저벡터의 시점인 원점이 이동해야 하기 때문입니다. 하지만 우리는 원점이 이동하는 변환은 다루지 않습니다. 선형성을 만족하지 못하니까요.

일반적으로 스크립팅 레벨에서는 덧셈으로 벡터를 이동시켜도 큰 문제는 없습니다. 그럼 덧셈을 통한 이동이 뭐가 문제라는 걸까요? 그냥 덧셈이 미워서? 아닙니다. 게임 엔진의 내부적인 렌더링 파이프라인에서는 덧셈을 쓸 수가 없어서 그렇습니다. 곱셈의 결합법칙으로 누릴 수 있는 엄청난 성능상의 장점을 포기해야 하기 때문이죠.

예를 들어 $$P\cdot V \cdot ( T + R \cdot S ) \cdot \vec{v}$$라는 연산을 진행해야 할 때, $$T$$와 $$R\cdot S$$가 곱셈으로 연결되었다면 다섯 개의 변환을 하나로 합쳐 연산량을 대폭 줄일 수 있게 됩니다. 하지만 덧셈으로 연결되었기 때문에 그럴 수 없습니다. 분배법칙에 의해 전개하면 아래와 같은 수식이 나오는데, 여기서 $$P\cdot V \cdot T$$와 $$P\cdot V \cdot R \cdot S$$를 각각 하나로 합친다 해도 결합법칙으로 모두 합쳤을 때에 비해 연산량이 2배나 많다는 걸 알 수 있습니다.

$$
(P\cdot V \cdot T + P\cdot V \cdot R \cdot S ) \cdot \vec{v}
$${: .align-center}

그래서 이런 변환 파이프라인을 간소화하기 위해서는 곱셈으로 벡터를 이동시키는 방법을 반드시 찾아야 합니다. 2차원 평면 공간에서는 불가능했으니, 차원을 3차원으로 확장해보면 어떨까요?

이게 무슨 소리냐면, 사실 2차원 평면 공간에서 1차원의 점들을 곱셈으로 이동시키는 게 가능했다는 겁니다. 전단 변환 행렬 $$\begin{bmatrix} 1 &a \\ 0 &1 \end{bmatrix}$$를 생각해 봅시다. 이 행렬은 공간의 $$y=1$$에 해당하는 벡터들을 $$x$$축 방향으로 $$a$$만큼 밀어냅니다.

![1](https://user-images.githubusercontent.com/90246317/171482825-66fc0e50-51fe-4b52-9615-1aa8af9479bf.gif){: .align-center}

$$y$$값이 $$1$$이 아닌 벡터들은 $$a=1$$보다 조금 덜 밀리거나, 더 밀리는 것을 볼 수 있습니다. 그리고 $$y=1$$인 벡터들을 모으면 사진에서 보이는 주황색 선이 되는데, 이 선은 1차원이라 할 수 있고, 여기에 속한 점들은 정확히 $$x$$축 방향으로 $$a$$만큼 이동합니다!

![2](https://user-images.githubusercontent.com/90246317/171482911-e631e9e5-56bf-4731-b760-48bac74dd39d.gif){: .align-center}

이걸 수식으로 나타내 보면, 1차원의 점들을 이동시키는 과정을 $$y$$가 $$1$$인 벡터들에 한해 $$a$$만큼 미는 전단변환으로 이해할 수 있습니다.

$$
\begin{bmatrix} 1 &a \\ 0 &1 \end{bmatrix}\begin{bmatrix} x \\ 1 \end{bmatrix}=\begin{bmatrix} x+a \\ 1 \end{bmatrix}
$${: .align-center}

그리고 우리는 2차원에서의 이동변환을 원하니까 3차원에서 변환을 수행하자는 이야기입니다. 일단 $$z$$축을 하나 만들고, 3차원이 어떻게 구성되어 있는지 봅시다.

![3](https://user-images.githubusercontent.com/90246317/171482908-73c648b3-bee2-4b75-8ae1-fff7b81b667f.png){: .align-center}

3차원의 기저벡터들은 $$(1,0,0),(0,1,0),(0,0,1)$$ 세 개 입니다. 각각 $$\hat{i}$$ (초록색), $$\hat{j}$$ (빨간색), $$\hat{k}$$ (파란색)라고 표기할 것입니다.

여기서 $$x$$축 방향으로 $$a$$만큼 미는 전단 변환은 아래와 같이 설계할 수 있습니다.

$$
\begin{bmatrix} 
 1 &0 &a \\
 0 &1 &0 \\ 
 0 &0 &1 \\
\end{bmatrix}
\begin{bmatrix}
 x \\
 y \\
 z \\
\end{bmatrix}
=\begin{bmatrix} 
x+a \\ 
y \\
z 
\end{bmatrix}
$${: .align-center}

그럼 공간은 다음과 같은 모습으로 변환되겠죠?

![4](https://user-images.githubusercontent.com/90246317/171482884-c7884d50-225b-4ebf-85b4-4de39cdaa363.gif){: .align-center}

$$y$$축 방향으로 $$b$$만큼 미는 전단 변환은 아래와 같을 것입니다.

$$
\begin{bmatrix} 
 1 &0 &0 \\
 0 &1 &b \\ 
 0 &0 &1 \\
\end{bmatrix}
\begin{bmatrix}
 x \\
 y \\
 z \\
\end{bmatrix}
=\begin{bmatrix} 
x \\ 
y+b \\
z 
\end{bmatrix}
$${: .align-center}

![37](https://user-images.githubusercontent.com/90246317/171482864-b6701285-6c26-4093-a71b-28bf448d2f0b.gif){: .align-center}

$$x$$축 방향으로 $$a$$만큼, $$y$$축 방향으로 $$b$$만큼 미는 전단 변환은 아래와 같이 설계될 것이고요. (이건 너무 복잡해져서 시각자료를 넣지는 않겠습니다.)

$$
\begin{bmatrix} 
 1 &0 &a \\
 0 &1 &b \\ 
 0 &0 &1 \\
\end{bmatrix}
\begin{bmatrix}
 x \\
 y \\
 z \\
\end{bmatrix}
=\begin{bmatrix} 
x+a \\ 
y+b \\
z 
\end{bmatrix}
$${: .align-center}

이 변환에서, **정확히 $$x$$축 방향으로 $$a$$만큼, $$y$$축 방향으로 $$b$$만큼 이동하는 벡터들은 $$z=1$$인 곳에 있겠죠?** 거기 모인 벡터들만을 모아 보면 아래와 같은 평면이 구성됩니다. 여기가 우리가 쓸 2차원 평면 공간이 되는 것입니다. 

![38](https://user-images.githubusercontent.com/90246317/171482859-36bc63d1-c163-4d5c-a014-229f7c31b5b6.png){: .align-center}

그럼 이 공간에서 벡터(로 구성된 물체)를 $$x$$축 방향으로 $$a$$만큼, $$y$$축 방향으로 $$b$$만큼 곱셈으로 이동시키는 변환은...

$$
\begin{bmatrix} 
 1 &0 &a \\
 0 &1 &b \\ 
 0 &0 &1 \\
\end{bmatrix}
\begin{bmatrix}
 x \\
 y \\
 1 \\
\end{bmatrix}
=\begin{bmatrix} 
x+a \\ 
y+b \\
1 
\end{bmatrix}
$${: .align-center}

이렇게 되겠네요! 당연하게도 이 변환에 사용된 행렬을 **이동변환행렬(Translate transformation matrix)**라 부릅니다. 그리고 줄여서 $$T$$로 표기합니다.

$$
T=\begin{bmatrix}
1 &0 &a \\
0 &1 &b \\
0 &0 &1 \\
\end{bmatrix}
$${: .align-center}

이제 이 공간에서 콘텐츠를 만들면 됩니다. 그런데 매번 ‘이 공간’ 또는 ‘3차원 공간에서 $$z=1$$인 벡터들이 모인 평면’이라고 하기 신경 쓰이고 귀찮지 않나요? 다행스럽게도 사람들은 이 공간에다 이미 이름을 붙여놓았는데, 바로 **‘아핀 공간(Affine space)**❤**’**입니다. 전단변환으로 이동 가능한 벡터들만을 모아놓은 곳이지요. 

아핀 공간은 특정 차원에만 한정되는 이야기는 아니고, 마지막 축에 해당하는 좌표가 1인 벡터들만 모아놓은 공간을 지칭하는 일반적인 용어입니다. 그리고 여기서 짐작할 수 있듯이, 3차원의 이동변환은 다음과 같이 4차원에서 설계됩니다.

$$
\begin{bmatrix} 
 1 &0 &0 &a \\
 0 &1 &0 &b \\ 
 0 &0 &1 &c \\
 0 &0 &0 &1 
\end{bmatrix}
\begin{bmatrix}
 x \\
 y \\
 z \\
 1
\end{bmatrix}
=\begin{bmatrix} 
x+a \\ 
y+b \\
z+c \\
1
\end{bmatrix}
$${: .align-center}

이렇게 차원을 한 단계 높여 표현한 좌표계를 동차 좌표계(Homogeneous coordinates)라 합니다.

아무튼, 아핀 공간을 통해 이동을 선형변환으로 구현하는 것은 차원을 확장함으로써 원점과의 연결고리를 만들어주는 것이나 마찬가지입니다. 기저벡터가 하나 더 생기니까 가능한 일입니다. 다음은 $$\hat{k}$$의 $$x,y$$좌표가 변함에 따라 아핀 공간의 벡터들이 이동하는 모습입니다.

![100](https://user-images.githubusercontent.com/90246317/171482854-88c04266-2f75-4ce5-a730-fd4391f93f69.gif){: .align-center}

정리해 봅시다.

<div class="notice--primary" markdown="1">
💡 **아핀 공간(Affine space)**
- **아핀 공간은 차원의 마지막 축에 해당하는 좌표가 1인 벡터들만 모아 만든 공간이다.**
- **아핀 공간의 구성 요소들은 선형변환으로 이동이 가능하다.**
</div>

<br/><br/>

## 아핀 변환(Affine transformation)

행렬 곱의 성능상의 이점을 살리기 위해서는 이동변환행렬과 크기변환행렬, 회전변환행렬의 크기가 모두 같아야 합니다. 그러므로 두 변환이 진행되는 차원을 한 단계 높여 아핀 공간에서의 변환으로 나타내 보겠습니다.

먼저 크기변환행렬입니다.

$$
S=\begin{bmatrix}
a &0 &0 \\
0 &b &0 \\
0 &0 &1 \\
\end{bmatrix}
$${: .align-center}

그리고 회전변환행렬입니다.

$$
R=\begin{bmatrix}
\cos\theta &-\sin\theta &0 \\
\sin\theta &\cos\theta &0 \\
0 &0 &1 \\
\end{bmatrix}
$${: .align-center}

사실 이 두 행렬은 차원을 늘림으로써 딱히 얻는 이점이 없습니다. $$\hat{k}=(0,0,1)$$로, $$\hat{k}$$가 하는 일은 실질적으로 아무것도 없습니다. 하지만 이동을 차원을 높여 구현하는 것의 이점(행렬곱의 결합법칙)이 너무 크기 때문에 이 두 행렬도 3차원으로 맞춰주는 거죠. 이렇게 동차 좌표계에서 설계한 선형변환을 **아핀 변환(Affine transformation)**이라고 하며, 크기변환행렬($$S$$), 회전변환행렬($$R$$), 이동변환행렬($$T$$)는 모두 아핀 변환의 행렬 표현입니다.

임의의 벡터 $$(x,y)$$에 대해 연산을 진행해보면 알 수 있듯이, 이 변환들은 아핀 공간에 닫혀 있습니다. 변환 후에도 $$z=1$$이니까요.

$$
\begin{bmatrix} 
 1 &0 &a \\
 0 &1 &b \\ 
 0 &0 &1 \\
\end{bmatrix}
\begin{bmatrix}
 x \\
 y \\
 1 \\
\end{bmatrix}
=\begin{bmatrix} 
x+a \\ 
y+b \\
1 
\end{bmatrix}\\
\begin{bmatrix} 
 a &0 &0 \\
 0 &b &0 \\ 
 0 &0 &1 \\
\end{bmatrix}
\begin{bmatrix}
 x \\
 y \\
 1 \\
\end{bmatrix}
=\begin{bmatrix} 
ax \\ 
by \\
1 
\end{bmatrix}\\
\begin{bmatrix}
\cos\theta &-\sin\theta &0 \\
\sin\theta &\cos\theta &0 \\
0 &0 &1 \\
\end{bmatrix}
\begin{bmatrix}
 x \\
 y \\
 1 \\
\end{bmatrix}
=\begin{bmatrix} 
x\cos\theta-y\sin\theta \\ 
x\sin\theta+y\cos\theta \\
1 
\end{bmatrix}
$${: .align-center}

<br/><br/>

## 아핀 공간의 구성 요소

아핀 공간에 속한 벡터들은 원칙적으로는 벡터가 맞지만, 별도로 **점(Point)**이라고 부릅니다. 앞으로 콘텐츠의 구성 요소는 모두 점이 되어야 할 것이며, 점에 대해 발생하는 모든 변환은 아핀 공간을 벗어나면 안 됩니다.

점은 $$P_1,P_2$$와 같이 표기합니다. 점의 좌표는 $$P_1(x_1,y_1,1), P_2(x_2,y_2,z_2,1)$$와 같이 표기합니다. $$P_1$$은 2차원 아핀 공간의 점, $$P_2$$는 3차원 아핀 공간의 점이겠네요.

<div class="notice--primary" markdown="1">
💡 점(Point)

- 행렬 곱으로 이동이 가능하다.
- 마지막 차원 값이 1이다.
</div>

그런데 벡터 공간에서의 벡터합처럼, 점과 점을 더해 버리면 그 결과는 아핀 공간을 벗어나게 됩니다. 두 점의 $$z$$값이 1이니까 둘을 더한 것의 $$z$$값은 2가 되어버리기 때문입니다. 아핀 공간에 닫혀있지 않은 것이죠. 

![101](https://user-images.githubusercontent.com/90246317/171482853-29793640-53cc-426b-a3b4-be9791f6691e.png){: .align-center}

그래서 덧셈을 통해 점을 이동시키려면 $$z$$값이 0인 것을 더해줘야 하는 것입니다. 예를 들어, 점 $$P_1(2,3,1)$$을 점 $$P_2(4,7,1)$$로 덧셈을 통해 이동시키고자 할 때는 $$(2,4,0)$$을 더해줘야 할 것입니다. 

![102](https://user-images.githubusercontent.com/90246317/171482852-8e997ade-bee5-483f-88d6-9398aafe7adf.png){: .align-center}

그러니까 덧셈으로 점을 안전하게 이동시키려면 점이 아닌 요소가 필요한 것입니다. 마지막 차원 값이 0인 요소 말입니다. 그 요소를 사람들은 **이동벡터** 또는 **변위벡터(Displacement vector)**라 부르기로 했습니다. 생략해서 그냥 **벡터**라고 부르기도 합니다. 그러나 이름이 같다고 해서 벡터 공간의 벡터와 헷갈리면 안 됩니다!

아핀 공간의 벡터는 물리학에서의 힘벡터와 비슷합니다. 지금까지 우리가 본 벡터 공간의 벡터는 원점에서 출발하는 화살표였습니다. 하지만 이동벡터는 점을 이동시키기 위한 수단으로, 시점은 어디든지 존재할 수 있습니다. 사실상 위치 개념이 없는 것이죠. 위에서 본 $$(2,4,0)$$도 벡터 공간의 벡터였다면 ‘원점으로부터 $$x$$축 방향으로 2만큼, $$y$$축 방향으로 4만큼 떨어진 벡터’로 해석되었겠지만, 이동벡터의 관점에서는 $$x$$축 방향으로 2만큼, $$y$$축 방향으로 4만큼 이동시키는 벡터’로 해석되는 것입니다.

<div class="notice--primary" markdown="1">
💡 **벡터(Vector)**

- 마지막 차원 값이 0이다.
- 아핀 공간 내의 이동을 지정하기 위해 사용된다.
</div>

그리고 위의 $$(2,4,0)$$은 당연하게도 $$P_2-P_1$$를 통해 만들어지는데, 그러므로 $$P_2-P_1$$은 “$$P_1$$에서 $$P_2$$로 향하는 벡터”를 의미하게 됩니다. 그럼 점과 벡터의 몇 가지 연산들이 무엇을 만들어내는지 정리해 봅시다.

<div class="notice--primary" markdown="1">
1. $$P_2-P_1=\vec{v}$$ ($$P_1$$에서 $$P_2$$로 향하는 벡터)
    <br/>점과 점의 뺄셈은 벡터를 만들어낸다. (방향 주의!)
    <br/><br/>

2. \\(P_1+\vec{v}=P_2\\)
    <br/>점과 벡터의 덧셈은 점을 만들어낸다.
    <br/><br/>

3. $$\vec{v_1}+\vec{v_2}=\vec{v_3}$$ ($$z=0$$이므로)
    <br/>벡터와 벡터의 덧셈은 벡터를 만들어낸다.
    <br/><br/>

4. $$P_1+P_2=$$??? (아핀 공간을 벗어남)
    <br/>점과 점의 덧셈은 아핀 공간에 닫혀있지 않다.
</div>

<br/><br/>

## 스크립팅 레벨에서 아핀 변환을 써야 할까?

행렬 곱을 사용해서 점을 이동시키는 작업은 렌더링 파이프라인의 효율 면에서 굉장히 유용합니다. 하지만 스크립트에서, 예를 들어 유니티의 Vector3 구조체를 사용할 때 점과 벡터를 구분하기 위해 0과 1을 넣어줘야 할까요?

굳이 그러지 않아도 됩니다. (용량 낭비입니다) 렌더링 파이프라인처럼 극도의 효율을 추구할 필요가 없을뿐더러, 행렬 곱을 사용해 이동을 구현하지 않는다면 3차원 벡터도 상황과 맥락에 따라 얼마든지 다르게 해석되고 적용될 수 있습니다. 그러니까 해석하기 나름인 것입니다. 어차피 나중에 렌더링 파이프라인에서 마지막 차원 값에 1을 넣어 계산해주기도 하고요. 엔진을 직접 만들 게 아니면 스크립팅 레벨에서는 덧셈을 통해 이동을 구현해도 충분합니다.

<br/><br/>

## 아핀 결합(Affine combination)과 직선의 방정식

앞서 점과 점의 합은 점이 될 수 없다고 설명했습니다. 하지만 점끼리 더할 때 특별한 계수를 곱해 준다면, 스러니까 스칼라배를 해준 다음 더한다면 두 점을 결합해 점을 만들어낼 수 있습니다.

점과 점의 합이 점을 만들어낼 수 없었던 이유는 마지막 차원의 값이 1이 아니게 되어버리기 때문이었죠? 그러면 계수를 통해 어떻게든 1로 만들어주면 됩니다. 예를 들어 $$P_1(x_1,y_1,1)$$과 $$P_2(x_2,y_2,1)$$을 더할 때, 합이 1이 되는 계수 $$a$$와 $$b$$를 각각 곱해주는 겁니다.

$$
aP_1+bP_2\\
=(ax_1,ay_1,a)+(bx_2,by_2,b)\\
=(ax_1+bx_2,ay_1+by_2,1)\\
=P_3
$${: .align-center}

그러면 둘을 더한 결과값은 $$z=1$$을 만족하므로 점이 됩니다. 점을 세 개 결합해 다른 점을 만들어내고 싶다면, $$a+b+c=1$$인 스칼라 $$a,b,c$$에 대해 다음과 같은 수식을 사용하면 됩니다.

$$
aP_1+bP_2+cP_3=P_4
$${: .align-center}

이렇게 여러 개의 점을 결합해 새로운 점을 생성하는 수식을 **아핀 결합(Affine combination)**이라고 부릅니다. 일단 간단하게 두 점의 아핀 결합부터 생각해 봅시다. $$a$$와 $$b$$의 관계를 명확히 해주기 위해 $$b$$를 $$(1-a)$$로 치환한다면, 다음과 같은 모습이 됩니다.

$$
aP_1+(1-a)P_2=P_3
$${: .align-center}

그런데 이 결합으로 생성되는 $$P_3$$들에게는 공통점이 있습니다. 일단 시각적으로 점 $$P_3$$이 어디에 생성될지를 생각해봅시다. $$P_3$$은 $$a=1$$일 때 $$P_1$$, $$a=0$$일 때 $$P_2$$가 됩니다. 그리고 $$a=0.5$$면 $$P_1$$와 $$P_2$$의 중점이 됩니다. (다음 그림은 3차원에서 $$z=1$$인 아핀 공간만을 보여줍니다)

![103](https://user-images.githubusercontent.com/90246317/171482847-27b758f1-31f6-4515-bb3a-bb75fce65b87.gif){: .align-center}

이런 식으로 $$a$$값이 달라짐에 따라 만들어지는 $$P_3$$들을 모아 보면 다음과 같은 모습이 됩니다. 

![104](https://user-images.githubusercontent.com/90246317/171482846-f0068b12-5b4c-45a9-98c3-ce5168642316.png){: .align-center}

그리고 $$a$$에 모든 실수를 대입한다면, 이렇게 양쪽으로 끝없이 뻗어나가는 **직선(Line)**이 되겠죠.

![105](https://user-images.githubusercontent.com/90246317/171482844-b26ea08d-0cee-46a9-9f7b-e53d22e1be5e.png){: .align-center}

이걸 수식으로 증명해봅시다. $$aP_1+(1-a)P_2=P_3$$을 정리해 보면,

$$
aP_1+P_2-aP_2-P_3=0\\
a(P_1-P_2)=P_3-P_2\\
a\vec{v}=\vec{u}
$${: .align-center}

$$P_1-P_2$$를 벡터 $$\vec{v}$$로, $$P_3-P_2$$를 벡터 $$\vec{u}$$로 나타내 보면, $$\vec{v}$$의 스칼라배를 통해 $$\vec{u}$$가 만들어진다는 것을 알 수 있습니다. 그리고 스칼라배로 만들어진 벡터는 항상 원래 벡터와 평행하므로, $$P_2$$에서 $$P_1$$으로 향하는 벡터와 $$P_2$$에서 $$P_3$$으로 향하는 벡터가 같은 직선 상에 위치함을 뜻하게 됩니다.

![106](https://user-images.githubusercontent.com/90246317/171482842-2ce790ff-67c0-47fc-91f2-51c07ee447a7.png){: .align-center}

그래서 $$a$$에 모든 실수를 대입한 수식을 직선의 방정식이라 부릅니다. 다음은 점 $$P_1$$과 $$P_2$$를 지나는 직선을 만들어냅니다.

$$
L(a)=a\cdot P_1+(1-a)\cdot P_2
$${: .align-center}

그런데 $$a$$의 범위를 $$[0,\infty)$$로 제한하면 다음과 같은 **반직선(Ray)**이 만들어질 것입니다.

![107](https://user-images.githubusercontent.com/90246317/171482840-e1d58a9e-e357-4d03-965c-a3b1a45d232c.png){: .align-center}

범위를 $$[0,1]$$로 제한하면 **선분(Line Segment)**이 만들어질 것이고요.

![108](https://user-images.githubusercontent.com/90246317/171482837-7593732f-ccef-4bfb-8b95-b66da75b264f.png){: .align-center}

이렇게 직선의 방정식의 범위를 제한해서 만들 수 있는 선의 종류에는 세 가지가 있는데, 직선(Line), 반직선(Ray), 선분(Line Segment)입니다.

**직선(Line)**은 두 점의 양쪽 방향으로 무한히 뻗어나가는 추상적인 선입니다.

**반직선(Ray)**은 지정한 위치에서 한쪽 방향으로만 무한히 뻗어나가는 선입니다. 이 역시 추상적인 성질을 가지지만, 뻗어나가는 범위를 제한해 게임 제작에서 여러 용도로 사용됩니다. 그 예로, 레이캐스팅(Raycasting)은 지정한 위치에서 반직선(Ray)를 던져(Casting) 이와 닿는 물체를 탐지합니다. 또 컴퓨터 그래픽스에서 각광받는 렌더링 기법인 레이트레이싱(Raytracing)은 픽셀 하나하나를 통과할 가상의 광선들을 역추적해(tracing) 그 빛의 경로를 계산해냅니다.

Line과 Ray는 무한이라는 추상적인 개념을 포함하기 때문에 실제로 콘텐츠로 존재할 수는 없습니다. 우리가 실제로 그리는 선은 시작점과 끝점이 있어야 하죠. 그게 바로 **선분(Line segment)**인 것입니다.