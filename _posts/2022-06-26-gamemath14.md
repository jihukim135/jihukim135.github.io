---
title:  "[게임수학] 14. 뷰 공간, 텍스처 매핑"
excerpt: 뷰 공간(View Space), 텍스처 매핑, 스프라이트 시트 활용 애니메이션 셰이더

categories: ["Game Math"]
tags:
  # - [math]

toc: true
toc_sticky: true

date: 2022-06-26
last_modified_at: 2022-06-26

sidebar_main: true

---

> 학교 수업과 함께 '이득우의 게임 수학'을 공부하며 정리한 내용들입니다. [책 구매하러 가기!](http://aladin.kr/p/6fBSV)  
> 같은 카테고리의 앞선 글을 모두 읽었다고 가정하고 작성되었습니다.  
> 이해되지 않는 부분이 있다면 한번 읽고 와 보세요! 

## 뷰 공간(View space)

로컬 공간은 모델러들이 다루는 공간이며, 물체 고유의 공간입니다. 월드 공간은 콘텐츠 개발자들이 다루는 공간이자 게임 엔진의 공간이죠. 하지만 이것만으로는 게임이 완성되지 않습니다. 모니터 화면에 콘텐츠가 출력되기 위해서는, 카메라가 만들어내는 공간이 필요하거든요. 카메라는 게임오브젝트로서 월드 공간에 존재하며, 이 카메라를 기준으로 하는 공간을 뷰 공간(View space) 또는 카메라 공간(Camera space)라고 합니다. 뷰 공간은 게임 플레이어를 위한 공간인 것이죠.

다음은 물체의 로컬 공간과, 월드 공간에 배치된 물체(로컬 공간)들, 그리고 뷰 공간(노란색 축이 나타내는 공간)을 보여줍니다.

![0](https://user-images.githubusercontent.com/90246317/187061450-7649c0b7-be05-4116-81a8-8e2bf6241701.png){: .align-center}

아무튼 콘텐츠 제작 과정에서는 월드 공간이 원점이자 모든 물체의 기준점이 되어야 하지만, 렌더링 과정에서는 뷰 공간이 원점이 되어야 합니다. 아래와 같은 느낌으로요.

![1](https://user-images.githubusercontent.com/90246317/187061458-0339256d-d078-4b00-9b5e-9b2138dd4ec6.png){: .align-center}

이렇게 월드에 배치된 물체들의 트랜스폼을 카메라 기준으로 재해석하려면 어떻게 해야 할까요? 여기서 우리는 카메라도 월드 공간의 게임오브젝트이며 그러므로 트랜스폼과 모델링 행렬을 가진다는 사실을 기억해야 합니다.

카메라의 위치와 회전값이(카메라 자체의 크기는 상관이 없습니다.) 각각 (0, 0), 0인 새로운 공간을 정의하는 쉬운 방법은 그냥 카메라의 로컬 공간이 월드 공간의 상태와 일치하도록 만드는 것입니다. 그리고 그 과정을 월드 공간의 다른 모든 물체들에게도 적용시켜 주면 카메라를 원점으로 하는 공간을 구축할 수 있습니다. 

그리고 카메라의 로컬 공간을 월드 공간의 원점과 일치시키는, 그러니까 변환된 카메라의 로컬 공간을 ‘되돌리는’ 작업은 카메라 모델링 행렬의 역행렬이 수행할 수 있습니다!

카메라의 트랜스폼에서 크기는 중요하지 않습니다. 그러므로 카메라의 모델링 행렬을 $$T_c\cdot R_c$$로 나타낼 수 있습니다. 행렬곱의 역행렬은 역행렬들을 각각 구한 다음 순서를 뒤집어 곱해주는 것으로 계산할 수 있습니다. 그러면 카메라 모델링 행렬의 역행렬은 $$R_c^{-1}\cdot T_c^{-1}$$가 될 것입니다. 이 행렬, 그러니까 월드 공간을 카메라 기준으로 변환시켜 주는 행렬을 **뷰 행렬(View matrix)**이라고 합니다. 우리는 이동변환행렬과 회전변환행렬의 역행렬을 구하는 법을 알고 있기 때문에, 다음과 같은 과정을 거쳐 뷰 행렬 $$V$$를 구할 수 있습니다. 카메라의 회전 트랜스폼이 $$\theta_c$$, 이동 트랜스폼이 $$(t_{cx},t_{cy})$$라 했을 때, $$T_c^{-1}$$와 $$R_c^{-1}$$는 다음과 같습니다.

$$
T_c^{-1}=\begin{bmatrix}
1 & 0 & -t_{cx} \\
0 & 1 & -t_{cy} \\
0 & 0 & 1
 
\end{bmatrix}
$$

$$
R_c^{-1}=\begin{bmatrix}
\cos\theta_c & \sin\theta_c & 0 \\
-\sin\theta_c & \cos\theta_c & 0 \\
0 & 0 & 1
 
\end{bmatrix}
$$

그리고 이 두 행렬을 곱해주면 됩니다(순서에 주의해서요).

$$
V=R_c^{-1}\cdot T_c^{-1}=\begin{bmatrix}
\cos\theta_c & \sin\theta_c & -t_{cx}\cdot\cos\theta_c-t_{cy}\cdot\sin\theta_c \\
-\sin\theta_c & \cos\theta_c & t_{cx}\cdot\sin\theta_c-t_{cy}\cdot\cos\theta_c \\
0 & 0 & 1
 
\end{bmatrix}
$$

그러니까 최종적으로, 물체의 로컬 공간의 좌표 $$v_{local}$$을 뷰 공간의 좌표로 바꿔 주는 행렬은 다음과 같이 $$VM$$으로 설계됩니다. 먼저 모델링 행렬을 통해 로컬 좌표를 월드 좌표로 바꾼 다음, 뷰 행렬을 통해 월드 좌표를 뷰 공간의 좌표로 바꿔주는 것입니다. 

$$
v_{view}=V\cdot M\cdot v_{local} \\
v_{view}=R_c^{-1}\cdot T_c^{-1}\cdot T\cdot R\cdot  S \cdot v_{local}
$$

3D 게임에서는 여기서 끝나지 않고 추가적으로 원근투영 과정이 필요합니다. 하지만 우리는 2D 게임의 공간을 다루고 있으니까 필요하지 않습니다!

<br/><br/>

## 텍스처 매핑

### UV 변형으로 텍스처의 특정 부분만 나오게 하는 셰이더 설계하기

아래와 같이 64 x 64 픽셀의 마인크래프트 스티브 텍스처가 있습니다. 그리고 이 텍스처는 가로와 세로를 균등하게 8등분으로 슬라이싱해 사용할 수 있도록 만들어졌습니다(점선은 편의상 그려놓은 것입니다).

![2](https://user-images.githubusercontent.com/90246317/187061460-a684c71c-c08a-456d-8ac6-2572e7c20dc9.png){: .align-center}

Quad나 Cube에 스티브의 얼굴만 나오게 하고 싶으면 어떻게 하면 될까요? 당연하게도 텍스처의 얼굴 부분에 해당하는 UV값을 찾아서 버텍스의 UV 정보에 넣어주면 되겠죠. 여기서 한 발짝 더 나가서, 행과 열 정보만 설정해 주면 알아서 해당하는 부분을 매핑시켜주는 셰이더를 설계해 보겠습니다. 행과 열의 인덱스는 편의상 0부터 시작하겠습니다. 

![3](https://user-images.githubusercontent.com/90246317/187061466-f381ddf9-bd5d-43c3-842f-e5d26c193092.png){: .align-center}

일단 완성된 셰이더를 던져놓고 시작하겠습니다. 행과 열 인덱스를 $$(1, 1)$$로 설정하면 다음과 같이 스티브 얼굴 부분만 매핑되어 나옵니다! 인덱스는 빨간색으로 표시된 RowIndex와 ColumnIndex 파라미터를 통해 설정합니다.

![4](https://user-images.githubusercontent.com/90246317/187061469-4e12a00b-a5c8-412e-9a65-8a471b598d19.png){: .align-center}

먼저 이 부분을 봅시다. 여기서는 행과 열 인덱스를 합쳐(Append) 2차원 벡터 값을 만들어냅니다. 행 인덱스가 B, 열 인덱스가 A에 연결된 이유는, 실질적으로 행 인덱스는 $$y$$(또는 V)좌표의 정보를, 열 인덱스는 $$x$$(또는 U)축 정보를 담고 있기 때문입니다. 그 다음 이 벡터를 $$[[0, 0], [1, 1]]$$ 범위의 UV 좌표계(TexCoord[0])에 더해 줍니다.

![5](https://user-images.githubusercontent.com/90246317/187061474-8be6e5f7-9a71-4eaf-ac62-67456fc7362b.png){: .align-center}

시각적으로 설명하면 이런 느낌입니다. 인덱스는 정수이고, UV 좌표계의 축 크기는 모두 1이기 때문에, 인덱스로 구성된 벡터를 모든 UV 좌표에 더해주면 다음과 같이 텍스처 하나를 단위로 행과 열 인덱스만큼 이동한 모습이 됩니다. 아래에서 빨간 사각형으로 표시된 부분이 현재 UV 좌표의 상태입니다.

![6](https://user-images.githubusercontent.com/90246317/187061476-9a2a37f8-ce11-4fa7-bcdd-c2cd680f48a8.png){: .align-center}

그런데 우리는 텍스처 전체가 아니라 텍스처의 그리드를 단위로 하는 [1][1]의 요소를 원하므로, 이 UV 좌표들을 작게 스케일링해줘야 합니다. 텍스처가 8행 8열로 등분되었으므로, 모든 좌표들의 V값을 $$\frac{1}{8}$$배로 줄이고, U값도 $$\frac{1}{8}$$배로 줄이면 됩니다.

![7](https://user-images.githubusercontent.com/90246317/187061478-799157b1-07b3-4428-8cc2-51f5fc4a8df8.png){: .align-center}

바로 여기가 그 작업을 수행하는 부분입니다. 가로 한 칸의 비율(GridWidthRatio), 세로 한 칸의 비율(GridHeightRatio)을 설정해 놓고, 두 값을 합쳐 만든 벡터를 아까 구한 UV 좌표들에 곱해주고 있습니다. Multiply는 벡터의 각 성분들끼리 곱하는 연산을 수행합니다. $$x$$성분끼리, $$y$$성분끼리 곱한 벡터를 만들어내는 것이죠. 이렇게 하면 정확히 우리가 원하는 행과 열에 해당하는 UV 좌표를 얻어낼 수 있습니다. 

![8](https://user-images.githubusercontent.com/90246317/187061480-468cfcc6-8a56-4ed6-8579-10cab574af3f.png){: .align-center}

<br/><br/>

### 스프라이트를 슬라이싱해 애니메이션을 재생하는 셰이더 설계하기

이번에는 비슷하지만 조금 더 재미있는 걸 해 보겠습니다. 다음과 같은 폭발 이펙트 스프라이트 시트가 있습니다. 이 스프라이트는 6 x 6 그리드로 구분되어 있습니다. 이 그리드의 요소들을 순서대로 시간의 흐름에 따라 재생시키고 싶으면 어떻게 해야 할까요?

![9](https://user-images.githubusercontent.com/90246317/187061485-4d0b2b92-61ff-46e9-9fd1-db36088649e9.png){: .align-center}

물론 이 기능은 이미 구현되어 제공되는 함수가 있습니다. FlipBook이라고 하는데 여기에 행의 개수와 열의 개수만 입력해 주면 알아서 UV를 만들어줍니다. 그걸 텍스처에 연결해주면 끝입니다… 하지만 지금은 직접 FlipBook을 구현해보기로 합시다.

![10](https://user-images.githubusercontent.com/90246317/187061495-3a0596fd-e9aa-4577-9195-83fb652ae79c.gif){: .align-center}

까다로운 점은 인덱스가 Time 노드의 출력값과는 다른 방식으로 변화해야 한다는 것입니다. Time 노드의 출력값은 1초에 1씩 계속해서 증가하지만 이 그리드의 인덱스는 그럴 수 없습니다. 그러니까 [0][1]에서 [0][5]까지는 평범하게 열 인덱스를 증가시키면 되지만, 그 다음부터는 열 인덱스가 다시 0으로 돌아가야 하고 행 인덱스는 1 증가해야 합니다. 게다가 [5][5]를 재생하고 나면 다시 [0][0]으로 돌아와야 하죠…

그럼 이렇게 생각해봅시다. 행과 열 인덱스는 일단 생각하지 말고, 이렇게 각 요소마다 순서대로 번호를 붙여보는 겁니다. 0부터 시작하면 35까지의 번호를 붙일 수 있습니다. 그리고 이 값은 Time 노드에 대한 전체 요소의 수(행의 개수와 열의 개수의 곱, 여기서는 6 x 6 = 36)의 나머지 연산으로 쉽게 구할 수 있습니다. 소수점은 절사하면 그만이고요. 

![11](https://user-images.githubusercontent.com/90246317/187061497-322b1629-a6fa-44d0-91ec-a74c45ba6327.png){: .align-center}

이렇게 0부터 35까지 반복적으로 증가하는 값을 가지고 행과 열 인덱스를 만들어낼 수만 있다면, 위에서 스티브 얼굴을 매핑할 때와 같은 방식으로 쉽게 해당 요소의 UV값을 얻어낼 수 있습니다. 그런데 생각해 보면 이렇게 각 요소에 부여된 순번들에는 다음과 같은 규칙이 있습니다.

![12](https://user-images.githubusercontent.com/90246317/187061501-633e3682-bbd6-41b5-8698-4a7a4f7d4fd0.png){: .align-center}

위 그림에서 빨간색 바탕이 칠해진 6은 행의 개수, 파란색 바탕이 칠해진 6은 열의 개수입니다. 이제 규칙이 보이지 않나요! 위에서 부여된 0~35번의 순번들은, (현재 행 인덱스) $$\times$$ (열의 개수) + (현재 열 인덱스)로 치환될 수 있습니다. 그러니까 **현재 행 인덱스는 0~35의 순번을 열의 개수로 나눈 몫이며, 현재 열 인덱스는 순번을 열의 개수로 나눈 나머지**라는 것입니다! 나누기와 나머지 연산을 통해 열과 행 인덱스를 구할 수 있는 것입니다.

그럼 이제 이걸 실제로 적용시켜봅시다. 늘 그랬듯이 완성된 셰이더를 먼저 던져놓고 시작하겠습니다. 복잡해 보이지만 위에서 설명한 걸 그대로 옮긴 것 뿐입니다… 차근차근 보겠습니다.

![13](https://user-images.githubusercontent.com/90246317/187061504-23b09ae5-b046-47c1-b242-c81a25c32a0f.gif){: .align-center}

전체적인 흐름을 파악하기 위해 어둡게 칠해진 부분은 일단 무시합시다. 여기서는 행 개수와 열 개수를 곱해(Multiply) 전체 요소 수를 만들어내고, Time 노드에 대한 전체 요소 수의 나머지 연산을 통해(Fmod) 반복적으로 0에서 35까지 1초에 1씩 증가하는 값을 만들어냅니다.

![14](https://user-images.githubusercontent.com/90246317/187061511-65419634-bc55-4bfe-b00e-720fae287511.png){: .align-center}

그 다음 이 값을 열 개수로 나눠서 행 인덱스를 구하고, 나머지 연산으로 열 인덱스를 구합니다. 이게 끝입니다. 이제 행과 열 인덱스를 구했으니 아까 스티브 셰이더를 만들 때처럼 두 값을 Append해서 벡터를 만들어주면 됩니다.

![15](https://user-images.githubusercontent.com/90246317/187061516-49a0704c-ef62-47d1-94db-70e8896a0acf.png){: .align-center}

이제 진짜 끝입니다. Divide와 Fmod는 소수점을 남겨놓기 때문에 Floor로 절사해줍니다. 인덱스는 정수가 되어야 하니까요. 그리고 인덱스로 만든 벡터를 UV값들에 더합니다.

가로와 세로 그리드 간격이 다를 경우를 대비해 미리 행 개수와 열 개수로 스케일링에 사용할 벡터를 만들어 놓았는데요, UV값들을 이 벡터도 나눠서 스케일링합니다(Divide). 그러면 시간에 따라 인덱스가 변화하고 해당 부분이 Cube에 매핑되면서 애니메이션이 만들어집니다.

![16](https://user-images.githubusercontent.com/90246317/187061524-737a764e-ff45-4993-a4e1-60e54b3f8379.png){: .align-center}

그러면 아까 무시했던 Speed를 다시 보겠습니다. 이 친구는 그냥 애니메이션 속도를 조절하는 역할을 합니다. 얘가 없으면 1초에 한 번씩 텍스처가 변해서 재생 속도가 굉장히 느려집니다. 저는 적당한 수를 곱해서 속도를 조절해줬습니다.

![17](https://user-images.githubusercontent.com/90246317/187061531-b8e82759-b681-4490-accb-46eaf071d5f0.png){: .align-center}
