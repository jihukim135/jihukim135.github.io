---
title:  "[게임수학] 9. 래스터화(Rasterization), 선 그리기 알고리즘"
excerpt: 스크린 좌표계, 픽셀(Pixel), 브레젠험 선 알고리즘(Bresenham's line algorithm), 코헨-서덜랜드 라인 클리핑 알고리즘(Cohen-Sutherland line clipping algorithm)
published: false

categories: ["Game Math"]
tags:
  # - [math]

toc: true
toc_sticky: true

date: 2022-05-07
last_modified_at: 2022-05-07

sidebar_main: true

---

> 학교 수업과 함께 '이득우의 게임 수학'을 공부하며 정리한 내용들입니다. [책 구매하러 가기!](http://aladin.kr/p/6fBSV)  
> 같은 카테고리의 앞선 글을 모두 읽었다고 가정하고 작성되었습니다.  
> 이해되지 않는 부분이 있다면 한번 읽고 와 보세요! 

## 스크린 좌표계(Screen coordinates), 래스터화(Rasterization)

데카르트 좌표계에 존재하는 무한대의 실수를 모두 화면에 그릴 수는 없습니다. 대신 이를 모니터에 표현하기 위한 **스크린 좌표계(Screen coordinates)**를 사용합니다.

스크린 좌표계의 $$y$$축은 데카르트 좌표계와 달리 아래쪽을 향하며, 좌표를 나타낼 때 연속적인(Continuous) 실수가 아닌 이산적인(Discrete) 정수를 사용합니다. 그러니까 $$x$$축과 $$y$$축 모두 수의 간격이 1인 것입니다. 그리고 이 이산적인 정수들로 이루어진 하나의 스크린 좌표는 하나의 네모난 영역에 대응됩니다. 이 네모난 영역을 **픽셀(Pixel)**이라 부릅니다.

![1](https://user-images.githubusercontent.com/90246317/171487316-da1044b8-36c9-481f-9d26-a4ef27b92c40.png){: .align-center}

데카르트 좌표계로 표현된 벡터 그래픽은 결국 출력 단계에서는 스크린 좌표계로 표현된 비트맵 그래픽으로 변환되어야 합니다. 왜냐하면 사실 벡터(또는 점)는 추상적인 개념으로, 좌표만 가질 뿐 면적이 없기 때문에 눈에 보이지 않거든요. 마찬가지로 벡터들을 모아 선을 만들어도, 그 선을 이루는 좌표들의 정보만 존재할 뿐입니다. 이걸 눈에 보이게 하려면 실수로 표현된 벡터 좌표를 정수로 변환해 스크린 좌표계의 픽셀에 대응시킨 후 색상을 지정해 주는 과정을 거쳐야 하는 것이죠. 그리고 이 과정을 **픽셀화 또는 래스터화(Rasterization)**라고 합니다.

![2](https://user-images.githubusercontent.com/90246317/171487342-782381ce-ccac-4b3c-a32c-c4e25961437c.png){: .align-center}

그런데 이 래스터화에는 규칙이 필요합니다. 연속적인 좌표를 이산적인 좌표로, 또는 그 반대로 변환해야 하기 때문에 당연합니다. 예를 들면 데카르트 좌표계의 원점에 대응하는 픽셀을 정할 때, 스크린 좌표계의 픽셀 수가 짝수라면 다음과 같이 어느 픽셀에 대응시켜야 할지 애매해집니다.

![3](https://user-images.githubusercontent.com/90246317/171487362-4e8cab3d-512f-40c2-9e76-909105f5bc0d.png){: .align-center}

또 스크린 좌표계의 픽셀을 데카르트 좌표계의 벡터로 변환할 때도, 픽셀의 영역에 해당하는 좌표 중 어느 것을 선택해야 할지 정해야 합니다.

![4](https://user-images.githubusercontent.com/90246317/171487381-ec5d2556-2b82-43ec-8e3e-70d692ae6a1b.png){: .align-center}

다행히도 이걸 구현한 제조사마다 래스터화 규칙(Rasterization rules)이라는 게 정해져 있습니다. 통일된 규칙은 없습니다. 그냥 엿장수 마음인 거죠. 다음은 MS 문서에서 가져온 Direct3D 11의 점 래스터화 규칙(Point Rasterization Rules) 관련 내용입니다. 요약하자면, 벡터를 픽셀로 변환할 때는 벡터를 중심으로 Z 모양의 두 삼각형으로 이루어진 정사각형을 만들고, 픽셀의 중심이 이 안에 들어오거나, 정사각형의 위쪽 혹은 왼쪽 모서리에 위치할 경우 그 픽셀을 그리는 방식입니다(top-left rule). 이 방식대로라면 원점에 있는 벡터는 스크린 좌표계에서 왼쪽 위의 픽셀로 칠해지겠네요. 또 픽셀을 벡터 좌표로 변환할 때는 픽셀의 중심을 사용한다고 합니다.

![5](https://user-images.githubusercontent.com/90246317/171487393-86bbdb3d-9281-426e-a036-cd8cc642c76f.png){: .align-center}

어찌됐건 이산적인 데이터를 연속적인 것으로, 또는 그 반대로 변환하는 과정에서는 데이터 로스가 일어날 수밖에 없습니다. 그래서 출력 단계에서만 래스터화를 해준다든지 하는 식으로 변환을 최소화해야 합니다.

마지막으로 데카르트 좌표계와 스크린 좌표계의 차이를 간단히 비교하고 마무리하겠습니다.

|  | 데카르트 좌표계 | 스크린 좌표계 |
| --- | --- | --- |
| 수집합 | 실수 | 정수 |
| 수의 성질 | 연속성 | 이산성 |
| 단위 원소 | 벡터 | 픽셀 |
| 수의 범위 | 모든 실수 | 0부터 해상도 크기까지 |

<br/><br/>

## 선 그리기 알고리즘이 필요한 이유

저번 글에서 직선의 방정식 $$L(a)=aP_1+(1-a)P_2$$을 설명했습니다. $$a$$값이 변화함에 따라 직선 상에 여러 개의 다른 점이 찍히니까, 점 $$P_1$$과 $$P_2$$를 잇는 선분을 만드려면 $$a$$를 0에서 1까지 차차 변화시켜주면 될 것입니다. 이 선분을 화면에 그리기 위해서 0과 1 사이에 존재하는 무한대의 실수를 모두 사용할 수는 없습니다. 그러므로 선분의 정밀도, 즉 $$a$$들 사이의 간격를 정해서, 0에서부터 1이 될 때까지 그 간격만큼을 더해주며 선분의 형상을 그리는 방법을 생각해볼 수 있습니다. 0.001 간격으로 더해준다든지, 0.0001 간격으로 더해준다든지 하는 식으로요.

이런 식으로 소수점이 존재하는 수를 더해 가며 그린 선분의 모습은 다음과 같겠죠.

![6](https://user-images.githubusercontent.com/90246317/171488321-c6366a7d-410a-4c93-9e8a-03f4d88b4303.png){: .align-center}

그런데 한 가지 의문은, 이 선분이 결국 픽셀화를 거쳐야 한다는 걸 생각해봤을 때, 이런 방식이 과연 효율적일까 하는 것입니다. 스크린 좌표계는 정수로 구성되어있기 때문에, 아래 그림처럼 하나의 픽셀에 여러 벡터가 대응될 수 있습니다. 아무런 유의미한 역할을 하지 않는 불필요한 벡터들이 발생하는 것이죠.

![7](https://user-images.githubusercontent.com/90246317/171488338-b68a1fb8-b228-402b-b344-5aaba48b6129.png){: .align-center}

게다가 컴퓨터가 막 만들어지기 시작했을 무렵인 6~70년대에는 부동소수점형 자체가 굉장한 연산량을 요구했습니다. 계산을 빠르게 하기 위해서 FPU(floating-point unit)라는 부동소수점 연산에 특화된 처리장치를 달아야 할 정도였어요. 그러니 이 방식으로는 선을 그리는 데 한 세월이 걸렸습니다. 그래서 정수만을 사용해 스크린 좌표계에 선을 그리는 데 필요한 픽셀만을 알아내는 알고리즘이 고안되었는데, 1962년에 발표된 브레젠험 선 알고리즘(Bresenham’s line algorithm)이 대표적입니다. 

<br/><br/>

## 브레젠험 선 알고리즘(Bresenham’s line algorithm)

브레젠험 선 알고리즘은 각을 기준으로 8등분된 팔분면(Octant)을 사용합니다. 스크린 좌표계는 $$y$$축이 아래쪽을 향하니, 시계방향이 양의 방향이자 곧 각의 진행 방향이 됩니다. 

![8](https://user-images.githubusercontent.com/90246317/171488354-595250c8-f518-495d-a769-e30e84c7102b.png){: .align-center}

그리고 선분의 시작점과 끝점이 어떤 모양을 하고 있는지(예: 시작점이 끝점보다 오른쪽에 있는지 아닌지), 경사가 어느 정도인지를 판단해 해당 선분이 어느 영역에 속해있는가를 알아낸 다음 그 영역에 해당하는 방식대로 선을 그려냅니다.

![9](https://user-images.githubusercontent.com/90246317/171488374-caec4056-87a0-442c-9fcd-f7f1dcf74a69.png){: .align-center}

먼저 첫 번째 영역인 제1팔분면으로 영역을 한정해 생각해봅시다. 제1팔분면은 사잇각이 $$[0^\circ, 45^\circ]$$의 범위를 가집니다. 이것은 제1팔분면에 해당하는 선분의 기울기가 $$[0,1]$$의 범위를 가진다는 것을 뜻합니다. $$y$$축이 데카르트 좌표계와 거꾸로 되어있다는 점을 기억하세요!

![10](https://user-images.githubusercontent.com/90246317/171488397-d48ab1c0-7be7-4e01-957e-54e54b77aa1d.png){: .align-center}

그런데 이런 범위를 가지는 선분의 특징이 있습니다. 그림에서도 보이는데, 선분을 포함하는 픽셀들이 시작점에서 멀어지며 **이전의 픽셀과 평행하거나, $$45^\circ$$ 대각선으로 한 칸 내려간 곳에 있는**(혹은 그 둘 모두가 해당되는) 모습을 보인다는 겁니다. 이걸 편의를 위해 ‘평행한 픽셀’과 ‘내려간 픽셀’로 부르겠습니다.

그럼 우리는 선이 얼마나 올라가 있고 내려가 있냐에 따라, 각 지점마다($$x$$가 1 증가할 때마다) 평행한 픽셀과 내려간 픽셀 중 어느 것을 선택할 건지만 정해주면 됩니다. 브레젠험 선 알고리즘에서는 **두 픽셀의 중점을 선택의 기준으로 사용**하는데, 그래서 이 알고리즘을 중점 알고리즘(Midpoint algorithm)이라 부르기도 합니다.

![11](https://user-images.githubusercontent.com/90246317/171488409-4c5dda70-b4bc-4f9e-b4a2-ac478699439a.png){: .align-center}

먼저 $$x=x_0+1$$일 때를 생각해봅시다. $$y$$좌표가 $$y_0+0.5$$보다 작으면 평행한 픽셀을, 크거나 같으면 내려간 픽셀을 선택해주면 되겠죠? 

![12](https://user-images.githubusercontent.com/90246317/171488447-8ed8fb3e-866b-4811-b091-03d8848d8d1c.png){: .align-center}

이걸 판별하기 위해 $$y=ax+b$$ 형태의 직선의 방정식을 활용해 봅시다. 일단 직선의 기울기를 알아내기 위해, 그리려는 선분의 너비($$w$$)와 높이($$h$$)를 구해보도록 하겠습니다.

![13](https://user-images.githubusercontent.com/90246317/171488462-c8ba9f04-e0bc-45a2-ae9c-5ca784a3cfdd.png){: .align-center}

이 선분은 제1팔사분면에 속해 있고 진행 방향이 $$x$$축이 증가하는 방향(오른쪽)이기 때문에, 기울기인 $$\frac{\Delta y}{\Delta x}$$가 $$\frac{h}{w}$$와 일치합니다. ($$\Delta x$$, $$\Delta y$$가 모두 양수니까요) 그러므로 직선의 기울기는 $$\frac{h}{w}$$로 구할 수 있고, 이 직선은 시작점인 $$(x_0,y_0)$$을 지나므로 $$y-y_0=\frac{h}{w}(x-x_0)$$과 같이 직선의 방정식을 구할 수 있습니다.

이걸 $$y$$에 대해 정리하면, 이런 모습이 됩니다.

$$
y=\frac{h}{w}(x-x_0)+y_0
$${: .align-center}

그러니까 우리는 직선 상의 점의 $$x$$값을 통해 그 점의 $$y$$값을 구할 수 있게 된 겁니다. 이 $$y$$값이 $$y_0+.5$$보다 작은지를 판별해야 하니까, 판별식은 아래와 같이 초기 설계될 것이고,

$$
\frac{h}{w}(x-x_0)+y_0 < y_0+0.5
$${: .align-center}

여기서 $$y_0$$을 소거한 다음, 양변에 $$w$$를 곱해 ($$w$$는 너비니까 양수이므로, 부등호 방향이 바뀌지 않습니다) 식을 정리하고...

$$
h(x-x_0)< 0.5w
$${: .align-center}

0.5를 좌변으로 옮긴 다음, 부동소수점형이 아닌 정수형으로 계산하기 위해 양변에 2를 곱해줍시다.

$$
2h(x-x_0)-w <0
$${: .align-center}

그리고 우리는 시작점에서 $$x$$가 한 칸 오른쪽으로 진행한 경우를 살펴보고 있기 때문에, $$x-x_0$$을 $$1$$로 바꿀 수 있습니다. 그럼 아래와 같은 판별식이 탄생합니다.

$$
2h-w<0
$${: .align-center}

그러므로 $$x=x_0+1$$일 때, 판별식 $$2h-w$$이 0보다 작으면 이전 픽셀과 평행한 픽셀을, 크거나 같으면 내려간 픽셀을 선택하면 되는 것입니다!

그럼 이제 세 번째 픽셀을 찍어봅시다. 여기서는 경우의 수가 좀 더 늘어나는데, 앞서 찍은 두 번째 픽셀이 평행한 픽셀이었냐 내려간 픽셀이었냐에 따라 판별을 위한 중점의 좌표가 달라지기 때문입니다. 각각의 경우의 판별식을 전부 구해봅시다.

![14](https://user-images.githubusercontent.com/90246317/171488484-135f9cae-f2bf-481e-9990-d8208446e706.png){: .align-center}

일단 위에 있는 중점의 판별식을 구하기 위해, 아까 여기까지 구했던 두 번째 픽셀의 판별식에서 $$x-x_0$$을 $$2$$로 바꿔줍시다. (이제 $$x_0$$에서 두 칸 진행한 상태니까요. $$y$$좌표는 아까와 동일하기에 뭔가 바꿔줄 필요가 없습니다.)

$$
2h(x-x_0)-w <0
$${: .align-center}

그럼 이런 판별식이 나오게 됩니다.

$$
4h-w<0
$${: .align-center}

이제 아래에 있는 중점의 판별식을 구해봅시다. 이것도 아까 두 번째 픽셀의 판별식을 구하는 이 과정에서,

$$
\frac{h}{w}(x-x_0)+y_0 < y_0+0.5
$${: .align-center}

우변을 $$y_0+0.5$$에서 $$y_0+1.5$$로 바꿔준 다음, 식을 조금 다듬고...

$$
h(x-x_0) < 1.5w
$${: .align-center}

$$x-x_0$$에 $$2$$를 대입한 다음 다시 정리해 주면 이런 판별식이 만들어집니다.

$$
4h - 3w<0
$${: .align-center}

여기서 픽셀의 진행에 따라 판별식이 어떻게 달라지는지 어렴풋이 깨달을 수 있는데, 오른쪽으로 한 칸 진행할 때마다 $$x-x_0$$이, 밑으로 한 칸 내려갈 때마다 우변의 상수항이 1씩 증가합니다. 그리고 이렇게 증가한 값들은 나중에 양변에 2를 곱해주는 과정을 거쳐 판별식의 좌변에 $$2h$$ 또는 $$-2w$$를 더해 주는 결과를 만들어내게 됩니다.

이렇게 $$x$$와 $$y$$값의 변화에 따라 달라지는 판별식의 패턴을 그림으로 나타내 보면 이런 모습입니다.

![15](https://user-images.githubusercontent.com/90246317/171488503-685058f8-24bc-4973-9917-af6a2332da24.png){: .align-center}

이런 규칙을 적용해 픽셀을 채워 보면, 오른쪽 그림처럼 되겠죠?

![16](https://user-images.githubusercontent.com/90246317/171488517-dba102e5-feff-491f-99b2-54b2a4085f10.png){: .align-center}

그리고 이 과정은 순서도로 정리할 수 있습니다. 

![17](https://user-images.githubusercontent.com/90246317/171488532-3787e5da-d9bc-4cb0-9833-c6813cd409b0.png){: .align-center}

이렇게 첫 번째 팔분면의 알고리즘이 완성됐습니다.

그럼 이제 두 번째 팔분면을 살펴봅시다. 두 번째 팔분면에서 픽셀은 $$[45^\circ,\infty)$$ 범위의 기울기를 가지며, $$y$$가 1 증가할 때마다 선을 포함하고 있는 픽셀들은 이전 픽셀과 $$y$$값이 같거나(평행하거나) 한 칸 오른쪽으로 이동한 위치에 있습니다. 그러니까 제1사분면과 비교했을 때 $$x$$과 $$y$$가 반대인 상황인 것입니다.

![18](https://user-images.githubusercontent.com/90246317/171488543-fa831c60-3c2a-4629-8d45-34414482e871.png){: .align-center}

이번에도 선택의 기준은 두 픽셀의 중점이 될 것입니다. 

![19](https://user-images.githubusercontent.com/90246317/171488563-898f2d22-9067-49e1-a1fa-b827d19c777c.png){: .align-center}

그럼 판별식을 세워봅시다. 직선의 방정식은 제1사분면에서와 동일하게 세우되 $$x$$에 대해 정리해줍시다.

$$
y-y_0=\frac{h}{w}(x-x_0)\\
\frac{w}{h}(y-y_0)=x-x_0\\
\therefore x=\frac{w}{h}(y-y_0)+x_0
$${: .align-center}

그리고 구한 $$x$$값과 $$x_0+0.5$$를 가지고 부등식을 세워줍시다.

$$
\frac{w}{h}(y-y_0)+x_0 < x_0+0.5
$${: .align-center}

이걸 정리하면 다음과 같은 모습이 됩니다. 사실 이렇게 유도하지 않아도, 제1팔분면과 제2팔분면은 $$y=x$$에 대해 대칭이니 $$y$$와 $$x$$(그러므로 $$h$$와 $$w$$)를 바꿔주기만 하면 된다는 건 쉽게 생각할 수 있습니다.

$$
2w-h<0
$${: .align-center}

그리고 아까와 같은 방식으로 규칙을 알아내보면 판별식은 이런 모습으로 변화합니다.

![20](https://user-images.githubusercontent.com/90246317/171488573-1f288839-40b5-412c-b2c1-1ebb535f56f9.png){: .align-center}

제3팔분면은 선분의 진행 방향이 반대이고, $$\frac{h}{w}$$와 $$\frac{\Delta y}{\Delta x}$$의 부호가 다르다는 점만 빼면 제1,2팔분면과 비슷합니다. 그리고 위의 두 차이점은 서로 상쇄되어 판별식은 제2사분면과 같이 $$2w-h$$로 설계됩니다. 이런 식으로 모든 팔분면의 판별식을 구해 보면...

![21](https://user-images.githubusercontent.com/90246317/171488593-10fe8d37-eb00-4ff4-979e-a281d10f42c8.png){: .align-center}

선분의 경사가 완만한, 그러니까 선분의 너비가 높이보다 큰 팔분면에서는 $$2h-w$$를, 높이가 너비보다 커서 경사가 급한 팔분면에서는 $$2w-h$$를 판별식으로 사용한다는 걸 알 수 있습니다.

그러므로 다음과 같은 과정을 거쳐, 정수 계산만을 사용해 효율적으로 선분을 그려낼 수 있게 됩니다.

1. 선분의 길이와 너비를 구한다.
2. 선분의 경사를 통해 어느 팔분면에 있는지 알아낸다.
3. 1,4,5,8팔분면에 속해있다면 판별식 $$2h-w$$를, 2,3,6,7팔분면에 속해있다면 판별식 $$2w-h$$를 통해 선분을 그린다. (그리는 과정은 위의 순서도를 참고!)

선 그리기 알고리즘에는 SONY PSP에서 사용한 Extremly Fast Line Algorithm(EFLA) 등의 더 빠른 알고리즘들도 존재하지만, 62년도에 발표된 브레젠험 알고리즘도 정말 빠른 편입니다. 아래에서 보이듯이 2005년 기준 3등으로 빨랐으니까요. ([출처](http://www.edepot.com/algorithm.html))

![22](https://user-images.githubusercontent.com/90246317/171488615-cf878369-e143-4c1b-82f0-c2bf76579386.png){: .align-center}

<br/><br/>

## 코헨-서덜랜드 라인 클리핑 알고리즘(Cohen-Sutherland line clipping algorithm)

브레젠험 알고리즘은 훌륭하지만 이것만으로 선을 그리기엔 충분하지 않습니다. 브레젠험 알고리즘의 특성상, 시작점과 끝점이 굉장히 큰 정수 값으로 이루어져 있더라도 한 칸씩 전진하며 처음부터 끝까지 모두 계산해야 하기 때문이죠. 그래서 화면을 벗어나는 영역에서 불필요한 계산이 발생하는 것을 막을 수 없습니다. 

때문에 화면을 벗어나는 시작점과 끝점을 스크린 좌표계에 속하는 영역으로 재설정해주는 작업이 필요한데, 이걸 **클리핑(Clipping)**이라고 합니다. 이번에는 1967년도에 발표된 **코헨-서덜랜드 라인 클리핑 알고리즘(Cohen-Sutherland line clipping algorithm)**에 대해 알아보겠습니다.

먼저, 다음과 같이 좌표가 속한 영역을 9개로 구분합니다. 그리고 각 영역에 4자리의 고유한 비트를 부여하는데, 이 비트로 영역을 식별합니다. 0000이 부여된 영역만이 화면 영역인데, 4자리 중 앞의 두 비트는 그 영역이 화면의 위아래 중 어디에 위치하는지를 나타냅니다. $$00$$이면 $$y$$값이 화면 영역의 범위 안에 있다는 뜻이며, $$10$$이면 그보다 작고(위에 있고), $$01$$이면 그보다 큼(아래에 있음)을 의미합니다. 또 뒤의 두 비트는 그 영역이 화면의 왼쪽에 있는지 오른쪽에 있는지를 구별하는 데 사용됩니다. $$01$$이면 $$x$$좌표가 화면 영역의 범위보다 작고(왼쪽에 있고), $$00$$이면 화면 안의 범위, $$10$$이면 화면 밖 오른쪽에 있다는 것을 의미합니다.

![23](https://user-images.githubusercontent.com/90246317/171488645-7aaf57b6-292b-4639-8a12-961d7432603b.png){: .align-center}

먼저, 선분의 시작점과 끝점이 모두 0000 영역에 있다면 클리핑 없이 그냥 선을 그리면 될 것입니다. 그러나 한 점이라도 0000을 벗어난 영역에 있다면 클리핑을 해 줘야겠죠.

![24](https://user-images.githubusercontent.com/90246317/171488656-bc57aaec-1892-41c3-818f-44c44313fc0a.png){: .align-center}

그런데 아래 그림의 오른쪽처럼 선분이 아예 0000 영역을 지나가지 않을 때는 선을 그릴 필요조차 없습니다. 그래서 선분이 화면 영역을 지나지 않는지를 빠르게 판단할 방법이 필요합니다. 불필요한 계산은 줄일 수록 좋으니까요.

![25](https://user-images.githubusercontent.com/90246317/171488670-58bca446-cb67-4b1b-9ff6-6223fd5d101d.png){: .align-center}

그러므로 선을 그릴 때 발생할 수 있는 상황은 다음의 세 가지로 추릴 수 있습니다.

1. 선이 화면 영역 안에만 존재하는 경우
2. 선의 일부 영역이 화면 영역을 벗어나서 클리핑이 필요한 경우
3. 선이 아예 화면 영역을 지나지 않아 그릴 필요가 없는 경우

1번은 선분의 시작점과 끝점이 속한 영역의 비트값을 구해 모두 0000이 나오는 경우입니다. 이럴 때는 그냥 클리핑을 건너뛰면 됩니다. (나이스!)

2번과 3번은 어떻게 구분할까요? 둘 다 시작점과 끝 점 중 적어도 하나는 0000 밖에 위치한다는 점만 빼면 공통점을 찾기 힘들어 보이는데 말입니다. 그런데 생각해 보면 3번에 해당하는 선분들은 다른 그들만의 공통점이 있습니다.

![26](https://user-images.githubusercontent.com/90246317/171488688-cb2888bc-aa30-44ee-904e-c2d9f8fceff5.png){: .align-center}

바로 **상하를 나타내는 2비트나 좌우를 나타내는 2비트 중 적어도 하나는 같다**는 것입니다. 그러니까 시작점과 끝점이 모두 0000이 아닌 영역에 있되, 같은 행이나 같은 열에 있으면 그 선분은 0000 영역을 통과할 일이 없다는 거죠. 이와 달리 0000 영역을 지나가는 2번의 경우에는 시작점와 끝점의 상하 비트와 좌우 비트가 모두 일치하지 않습니다. 같은 행에 있지도 같은 열에 있지도 않은 겁니다.

![27](https://user-images.githubusercontent.com/90246317/171488706-c9773bd3-1171-4d7a-b224-e02077a53d75.png){: .align-center}

그리고 이것은 &(And) 비트연산을 통해 판별해낼 수 있는데, 상하 비트와 좌우 비트가 모두 다른 경우 두 값의 & 연산 결과는 항상 0000이 됩니다. 그리고 **상하와 좌우 비트 중 하나라도 같을 경우, & 연산을 하면 1이 적어도 하나는 발생**하게 됩니다. 즉, 연산 결과가 0이 아니게 됩니다!

그러므로, 시작점과 끝점의 영역 값을 & 연산한 결과가 0이면 2번 경우에 해당하는 선분, 0이 아니면(0보다 크면) 3번 경우에 해당하는 선분이라고 판별해낼 수 있는 것입니다.

그런데 이런 경우도 있지 않을까요? 선분이 0000 영역을 지나 클리핑이 필요하지만 시작점과 끝점의 상하 또는 좌우 비트가 같은 경우 말입니다.

![28](https://user-images.githubusercontent.com/90246317/171488722-bb4e6280-2747-4292-ac4e-efa7f7753bec.png){: .align-center}

하지만 0000이 속한 열이나 행의 상하와 좌우 비트는 모두 00으로 설정되었기 때문에, 비트가 같아도 & 연산으로 1이 발생할 수 없게 됩니다. 결과적으로 연산 결과가 0인 2번의 경우에 포함되는 겁니다. 진짜 변태같네요...

아무튼 이 알고리즘의 핵심을 정리하자면 이렇습니다.

1. 9개의 영역을 만들고 상하 비트와 좌우 비트를 부여한다.
2. 선분의 시작점과 끝점이 어디에 속해있는지를 알아낸다.
    1. 모두 0000에 속해있다면 클리핑을 건너뛰고 선분을 그린 후 작업을 끝낸다.
    2. a에 해당하지 않을 경우, 시작점과 끝점이 속한 영역의 비트값을 & 연산한 결과가 0보다 크면 그리지 않고 작업을 끝낸다.
    3. a와 b에 모두 해당하지 않을 경우, 직선의 방정식을 통해 클리핑을 진행하고 2번으로 돌아간다.

사실 아래에 보이는 선분처럼 & 연산 결과가 0이어도 화면을 통과하지 않는 경우가 있긴 합니다.

![29](https://user-images.githubusercontent.com/90246317/171488736-11cdb5dc-935f-4a48-8434-d4931fe2a1d9.png){: .align-center}

그러나 이 선분이 화면을 지나는 선분이라고 판별된 다음 클리핑을 당하면(?), 다시 위 과정의 2번 단계로 돌아가 검사를 받을 때는 & 연산 결과가 0보다 커지게 되므로, 마찬가지로 선분을 그리지 않고 작업을 끝낼 수 있게 됩니다. 그러니 걱정할 필요 없습니다!

![30](https://user-images.githubusercontent.com/90246317/171488757-69526314-a238-41e9-abdb-5c68530673b9.png){: .align-center}

코헨-서덜랜드 라인 클리핑 알고리즘은 직선의 방정식으로 클리핑할 좌표를 구할 때 부동소수점 연산을 쓰긴 하지만, 많아봤자 두 번입니다. 매우 효율적으로 클리핑 작업을 수행할 수 있게 되는 것이죠.

<br/><br/>

## 사용된 툴과 자료들

- 이득우의 게임수학

- [Raster Algorithms (Basic Computer Graphics) Part 3](http://what-when-how.com/computer-graphics-and-geometric-modeling/raster-algorithms-basic-computer-graphics-part-3/)

- [Algorithms at edepot.com by Po-Han Lin](http://www.edepot.com/algorithm.html)

- [Rasterization Rules - Win32 apps : Microsoft Docs](https://docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules)

- [Rasterisation - Wikipedia](https://en.wikipedia.org/wiki/Rasterisation)

- [벡터 그래픽 - 내위키](https://www.newiki.net/wiki/%EB%B2%A1%ED%84%B0_%EA%B7%B8%EB%9E%98%ED%94%BD)