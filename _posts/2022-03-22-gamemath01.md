---
title:  "[게임수학] 1. 수(Number)"
excerpt: 공리적 집합론(Axiomatic set theory), 체(Field), 함수(Function)
published: false

categories: ["Game Math"]
tags:
  # - [math]

toc: true
toc_sticky: true

date: 2022-03-22
last_modified_at: 2022-03-22

sidebar_main: true

---

> 학교 수업과 함께 '이득우의 게임 수학'을 공부하며 정리한 내용들입니다. [책 구매하러 가기!](http://aladin.kr/p/6fBSV)  
> 같은 카테고리의 앞선 글을 모두 읽었다고 가정하고 작성되었습니다.  
> 이해되지 않는 부분이 있다면 한번 읽고 와 보세요! 

## 수(Number)와 집합(Set)

가상 세계를 구성하는 가장 작은 단위는 **수(Number)**입니다. 그리고 수를 이해하기 위해선 수를 **집합(Set)**이라는 관점에서 바라볼 필요가 있습니다. 우리는 이미 중고등학교 수학 시간에 집합에 대해 배운 적이 있지요!(아마도.) 집합이란, 서로 구분되는 원소(Element)들로 구성된 하나의 묶음을 의미합니다.

![b](https://user-images.githubusercontent.com/90246317/170730078-0cb17a87-96b1-46c1-b20d-41c43908c7d0.png){: .align-center}

그러나 사실 중고등학교 과정에서 배웠던 위의 내용은 **소박한 집합론(Native set theory)**에 해당합니다. 소박한 집합론에서는 인간의 언어로 집합을 정의하며, 집합을 단순히 대상들의 모임으로 이해합니다.

예를 들면, 자연수는 물건을 세거나 순서를 지정하기 위해 사용하는 수들의 집합입니다. $$1, 2, 3$$과 같은 것들이죠. 정수는 자연수와 자연수의 음수, 그리고 $$0$$을 포함하는 수의 집합입니다. $$-1, 0, -3, 5$$ 등이 정수에 해당합니다. 유리수는 두 정수로 이루어진, 분모가 0이 아닌 분수로 나타낼 수 있는 수들입니다. $$1.5, \frac{2}{3}, -0.005$$ 등이 유리수에 해당합니다. 이런 식으로 정의한 수집합들의 관계를 벤 다이어그램(Venn diagram)으로 나타내면 다음과 같은 모습이 됩니다.

![b](https://user-images.githubusercontent.com/90246317/170730082-a15f152a-4934-4904-97b4-b40211e01550.png){: .align-center}

하지만 이런 소박한 집합론은 인간의 보편적인 관념에 의존하므로 컴퓨터에게 이해시키기에는 부적합합니다. 우리는 수가 가지는 특성을 분석하고 이를 확장해 가상 공간을 설계해야 하기 때문에, 수집합을 정의하는 더 명확한 체계가 필요해요. 바로 **공리적 집합론(Axiomatic set theory)**입니다.

<br/><br/>

## 공리적 집합론(Axiomatic set theory)

명제(Proposition) 중에서 증명할 필요가 없는 기본 명제, 무조건 참이라고 받아들여야 하는 명제를 **공리(Axiom)**라고 합니다. 공리적 집합론은 공리를 기반으로 대상을 구분하는 집합론이고요. 컴퓨터 그래픽스의 세계는 공리로부터 만들어지는 것이지요. 지금부터는 수가 가지는 연산에 대한 공리를 기반으로 수를 분류할 거예요. 그럼 수의 연산에 대해 자세히 알아봅시다.

<br/><br/>

## 연산과 수의 구조

연산은 수들끼리의 상호작용입니다. 그리고 연산이 없으면 수집합은 그저 한곳에 모인 원소들일 뿐입니다. 즉 원소들이 수로서의 의미를 가지게 해 주는게 연산인 거죠. 이렇듯 집합의 원소들로 연산을 한다는 점은 수집합들의 공통된 특징이라 할 수 있어요.

연산 중에서도 두 개의 원소를 사용해 새로운 원소를 만들어내는 연산들을 **이항연산(Binary operation)**이라고 합니다. 덧셈, 뺄셈, 곱셈, 나눗셈의 사칙연산도 이항연산에 해당합니다. 예를 들면, '$$3 + 5 = 8$$'이라는 연산은 자연수 집합의 원소인 $$3$$과 $$5$$를 사용해 $$8$$이라는 원소를 만들어내는 과정으로 생각할 수 있어요.

![b](https://user-images.githubusercontent.com/90246317/170730091-a89c149e-626e-44a1-a7e9-a1629005dfaf.png){: .align-center}

또한 이항연산은 세 가지 성질을 지니는데, **교환법칙(Commutative law), 결합법칙(Associative law), 분배법칙(Distribute law)**이 바로 그것입니다. 그럼 하나씩 차근차근 살펴볼게요.

<br/>

### 교환법칙(Commutiative law)

교환법칙은 임의의 두 수 $$a$$와 $$b$$를 연산할 때 순서에 관계없이 항상 동일한 결과가 나오는 성질입니다.

\\[a+b = b+a​\\]
\\[a\cdot b = b\cdot a​​\\]

$$3 + 5$$와 $$5 + 3$$은 $$8$$로 같고, $$2 \cdot 5$$와 $$5 \cdot 2$$는 $$10$$으로 같죠? 정수의 덧셈과 곱셈 연산이 교환법칙을 만족해서 그렇습니다. 

<br/>

### 결합법칙(Associative law)

결합법칙은 연산이 두 번 이상 연속될 때, 앞의 연산을 먼저 계산한 것과 뒤의 연산을 먼저 계산한 것의 결과가 같은 성질입니다.

\\[(a+b)+c = a + (b + c)\\]
\\[(a\cdot b)\cdot c = a\cdot (b\cdot c)\\]

$$3 + 5 + 2$$를 $$8 + 2$$로 계산해도, $$3 + 7$$로 계산해도 결과는 $$10$$으로 같습니다. 또 $$2 \cdot 3 \cdot 4$$를 $$6 \cdot 4$$로 계산해도, $$2 \cdot 12$$로 계산해도 결과는 $$24$$로 같아요. 

<br/>

### 분배법칙(Distribute law)

분배법칙은 서로 다른 2가지 연산에 대해 다음의 규칙이 성립되는 성질입니다.

\\[a\cdot(b+c)=a\cdot b + a\cdot c\\]
\\[(b+c)\cdot a = b\cdot a + c\cdot a​ $\\]

![b](https://user-images.githubusercontent.com/90246317/170730101-d76725fd-cff9-454e-ae42-7b7e50c6254b.png){: .align-center}

위와 같이 연산이 분배되는 모습이라 분배법칙이라고 불러요. 또, 위의 식을 **좌분배법칙**, 아래의 식을 **우분배법칙**이라 부릅니다. 굳이 좌분배법칙과 우분배법칙을 나누는 이유는 두 연산의 결과가 다를 수 있기 때문입니다. 하지만 두 분배법칙을 모두 만족한다면, 두 연산의 결과가 달라도 분배법칙을 만족한다고 볼 수 있습니다. 그 예로 사원수(Quaternion)의 곱셈은 분배법칙을 만족하지만 좌분배와 우분배가 같지 않습니다.

또 한 가지 주의할 점은, **이 세 개의 연산법칙들은 서로 무관하다**는 점입니다. 하나의 연산법칙을 만족하지 못해도 다른 연산법칙을 만족할 수 있습니다. 예를 들어 벡터의 외적은 교환법칙과 결합법칙을 만족하지 않지만 분배법칙을 만족합니다.

그리고, 같은 집합에 속한 두 수를 이항연산한 결과가 항상 그 집합에 속한다면, 그 이항연산은 해당 집합에 대해 **닫혀 있다(Closure)**라고 표현한다는 것도 알아둡시다.

마지막으로 소개할 이항연산의 성질은 항등원(Identity)와 역원(Inverse)입니다. 이것도 하나씩 소개해보도록 할게요.

<br/>

### 항등원(Identity)

**항등원**이란, 어떤 수와의 연산 결과를 항상 동일한 수로 만들어 주는 특별한 수를 말합니다.

예를 들면, 어떤 수 $$a$$에 $$1$$을 곱하면 그 결과는 항상 $$a$$이고, $$a$$에 $$0$$을 더한 결과도 항상 $$a$$입니다. 그래서 **$$1$$을 곱셈의 항등원, $$0$$을 덧셈의 항등원**이라 부릅니다.

\\[1\cdot a = a​\\]
\\[a+0=a \\]

![b](https://user-images.githubusercontent.com/90246317/170730107-ec695141-c9e8-4fb8-9106-99aaebd0192f.png){: .align-center}

<br/>

### 역원(Inverse)

**역원**이란, 어떤 수와의 연산 결과를 항상 항등원으로 만들어 주는 특별한 수를 말합니다.

곱셈의 항등원은 $$1$$이니, 어떤 수 **$$a$$의 곱셈의 역원은 $$a$$의 역수(Reciprocal)인 $$1/a$$**가 됩니다. 단, 분모가 $$0$$인 분수는 존재하지 않으므로 **$$0$$의 곱셈에 대한 역원은 없습니다.**

또 덧셈의 항등원은 $$0$$이니, 어떤 수 **$$a$$의 덧셈의 역원**은 $$a$$의 반대수(Opposite number)인 **$$-a$$가 되겠군요.**

\\[a + (-a) = 0\\]
\\[a\cdot (\frac{1}{a}) = 1\\]

![b](https://user-images.githubusercontent.com/90246317/170730114-95d06332-c540-4739-bc50-fb7b87ff40fd.png){: .align-center}

<br/><br/>

## 결합법칙이 가지는 장점은 무엇일까

결합법칙은 주어진 식을 꼭 앞에서부터 차례대로 계산하지 않아도 되게 해 줍니다. 어떤 순서로 계산하더라도 항상 동일한 결과가 보장되기 때문입니다. 또 $$a \cdot b \cdot c$$와 같이 연산 횟수가 많은 식을 "$$a \cdot d$$" ($$d = b \cdot c$$라 할 때)와 같이 줄여준다는 장점도 있습니다. $$a$$값을 달리해서 식을 만 번 처리해야 한다고 할 때, $$a \cdot b \cdot c$$는 총 2만 번의 연산을 요구하지만 $$a \cdot d$$는 처음에 $$b \cdot c$$를 한 번만 계산한 뒤 만 번의 연산으로 처리 가능한 것이지요. 그래서 프로그램의 최적화에도 굉장히 중요합니다.

<br/><br/>

## 수의 구조

어떤 연산에 대해 다음의 공리를 만족하는 수 집합을 생각해 봅시다.

1. 연산에 대해 닫혀 있다.
2. 연산에 대해 결합법칙이 성립한다.
3. 연산에 대한 항등원이 존재한다
4. 연산에 대한 역원이 존재한다.
5. 연산에 대해 교환법칙이 성립한다.

정수의 덧셈은 위 공리를 모두 만족합니다. 두 정수의 합은 항상 정수이며, 교환법칙과 결합법칙이 성립하고, 항등원인 반대수와 역원인 0이 존재합니다.

그럼 정수의 뺄셈은 어떨까요? 아쉽게도 정수의 뺄셈은 교환법칙이 성립하지 않습니다. $$3 - 5$$와 $$5 - 3$$은 다르니까요.


그럼 연산을 하나 더 추가해서 두 개의 연산에 대한 공리를 생각해보도록 합시다.

6. 두 번째 연산에 대해 닫혀 있다.
7. 두 번째 연산에 대해 결합법칙이 성립한다.
8. 두 번째 연산에 대해 교환법칙이 성립한다.
9. 두 번째 연산에 대한 항등원이 존재한다.
10. 두 번째 연산에 대한 역원이 존재한다.
11. 첫 번째 연산과 두 번째 연산에 대해 분배법칙이 성립한다.

이번에는 정수의 덧셈에 곱셈을 추가해 봅시다. 두 정수의 곱은 항상 정수이며, 정수의 곱은 결합법칙과 교환법칙이 성립하고, 항등원인 $$1$$이 존재합니다. 또 덧셈과 곱셈에 대해 분배법칙이 성립해요. 하지만 정수 곱셈의 역원은 항상 정수가 아닙니다. 정수 $$a$$에 대해 $$\frac{1}{a}$$는 정수가 아닐 수 있기 때문입니다. 그래서 정수의 덧셈과 곱셈은 위 공리를 만족하지 못합니다.

그럼 덧셈과 곱셈에 대해 위 11개의 공리를 만족하는 수집합은 무엇이 있을까요? 일단 자연수와 정수는 곱셈의 역원이 존재하지 않으므로 공리를 모두 만족하지 못합니다. 하지만 **유리수와 실수**는 위 공리를 모두 만족합니다! 곱셈의 역원이 집합 내에 존재하기 때문이지요.

이렇게 두 연산에 대해 위 11개의 공리를 모두 만족하는 수집합은 **체(Field)**의 구조를 가진다고 표현합니다. 어떤 수집합이 체의 구조를 가지는 것은 **예외상황 없이 그 집합 내에서 안전하게 연산을 수행할 수 있다**는 것을 의미합니다. (코딩할 때도 안전!)

여기까진 좋지만, 그러면 유리수와 실수 집합에서 뺄셈과 나눗셈을 자유롭게 사용할 수는 없는 걸까요? 아닙니다. 뺄셈을 덧셈의 역원과의 덧셈, 나눗셈을 곱셈의 역원과의 곱셈으로 생각하면 됩니다.

자세히 설명하자면, $$3 - 5$$는 $$3 + (-5)$$로 나타낼 수 있죠? 여기서 $$-5$$는 $$5$$의 덧셈에 대한 역원입니다. 둘을 더하면 $$0$$이 되니까요. 그래서 $$3 + (-5)$$와 $$(-5) + 3$$은 $$-2$$로 결과가 같습니다. 

또 $$3 ÷ 4$$는 $$3 \cdot \frac{1}{4}$$로 나타낼 수 있는데, 여기서 $$\frac{1}{4}$$는 $$4$$의 곱셈에 대한 역원입니다. 둘을 곱하면 $$1$$이 되거든요. 역시나  $$3 \cdot \frac{1}{4}$$와 $$\frac{1}{4} \cdot 3$$은 $$\frac{3}{4}$$로 같아요.

이렇듯 유리수와 실수 집합 내의 모든 뺄셈과 나눗셈은 덧셈과 곱셈으로 표현할 수 있기 때문에, 수 집합이 공리를 만족하는지 확인할 때는 덧셈과 곱셈만을 살펴보는 것으로 충분합니다.

정리하자면, 유리수와 실수는 공리적 집합론으로 정의된 체의 구조를 가지고 있으며, 사칙연산에 대해 자유롭습니다. 그럼 이런 연산들을 시각적으로 표현하는 방법에 대해 알아봅시다.

<br/><br/>

## 수의 표현

실수 집합을 사용해 덧셈과 곱셈 연산을 시각화해 봅시다. 직선 상에 유리수 집합의 원소를 순서대로 모두 나열하면 빈틈이 발생합니다. $$\pi$$(pi, 원주율)나 $$\sqrt{3}$$과 같은 무리수를 표현할 수 없거든요. 하지만 실수 집합은 모든 무리수를 포함하기 때문에, 직선을 완벽히 연속적으로 채울 수 있습니다. (그래서 사실 프로그래밍에서 사용하는 자료형인 float이나 double도 엄밀히 말하면 실수형은 아닙니다. 부동소수점형의 정밀도 문제로 인해 모든 실수를 완벽하게 표현할 수 없으니까요.) 이렇게 실수를 점에 대응시켜 만든 직선을 수직선(Number line, 수 + 직선)이라 합니다.

![b](https://user-images.githubusercontent.com/90246317/170730120-9516b45e-3b6c-4507-8a3e-5719fd01418f.png){: .align-center}

또, 수를 원점($$0$$)으로부터의 크기와 방향을 가진 화살표로 표현할 수도 있습니다.

![b](https://user-images.githubusercontent.com/90246317/170730125-a1a59ff3-a9af-4c9a-9f4a-e973d51a98a7.png){: .align-center}

위 그림에서 $$-2$$는 $$0$$에서부터 왼쪽(방향)으로 $$2$$(크기)만큼 떨어진 화살표이며, $$2$$는 $$0$$에서부터 오른쪽(방향)으로 $$2$$(크기)만큼 떨어진 화살표가 됩니다. 참고로 어떤 수의 원점으로부터의 거리는 절댓값(Absolute value)이라고 하며, $$a$$의 절댓값은 $$\lvert a\rvert$$로 나타낼 수 있습니다. 거리는 음수가 될 수 없으므로, 음수든 양수든 절댓값 기호를 씌우면 양수가 되겠네요.

$$\lvert a \rvert = -a (a<0)$$
$$\lvert a \rvert = a (a >= 0)$$

($$0$$은 어차피 $$-$$를 붙여도 $$0$$이니, 첫 번째 식을 만족한다고 볼 수도 있습니다.)

그러면 이제 덧셈과 곱셈을 시각적으로 표현해 봅시다. 이항연산에서 왼쪽 항의 수를 물체를 구성하는 점으로, 오른쪽 항의 수를 점을 이동시키는 힘으로 생각하면, **덧셈은 점을 왼쪽 또는 오른쪽 방향으로 이동시키는 작업**으로 해석할 수 있습니다.

![b](https://user-images.githubusercontent.com/90246317/170730130-3a2d71f5-df1d-41c2-bda1-f81488c2da83.png){: .align-center}

또 **곱셈은 점과 원점 사이의 거리를 늘리고 줄이거나 점을 회전시키는 작업**으로 해석할 수 있습니다.

![b](https://user-images.githubusercontent.com/90246317/170730140-f4dc8eb1-b15f-4371-850a-3391a3896356.png){: .align-center}

덧셈은 이동을 담당하고, 곱셈은 크기와 회전을 담당하는 것이죠. 여러 게임 엔진에서 물체의 상태를 결정짓는 Transform이 Position(Location), Scale, Rotation으로 이루어진 것을 생각하면 재미있습니다.

또 크기가 $$1$$인 수와의 곱셈은 회전만 시키는 연산이며, 양수와의 곱셈은 크기만 바꾸는 연산이라는 것도 기억해 둡시다.

<br/><br/>

## 함수(Function)의 개념과 종류

**함수(Function)**란, 두 집합에 대해 첫 번째 집합(**정의역, Domain**)의 모든 원소가 두 번째 집합(**공역, Codomain**)의 어떤 원소에 대응하며, 정의역의 각 원소들은 공역의 오직 한 원소에만 대응되는 관계를 말합니다.

<div class="notice--primary" markdown="1">
💡 <u>함수의 조건</u>

1. 정의역의 모든 원소가 공역의 원소와 대응관계를 가져야 한다.
2. 정의역의 원소는 공역의 오직 한 원소에만 대응되어야 한다.
</div>

왜 이런 조건이 필요한지 생각해 봅시다. 함수는 어떤 원소를 넣으면 그에 대응하는 항상 동일한 원소를 뱉어내는 기계와 같습니다. 음료수 자판기랑 비슷한 거죠. 자판기라는 함수에서 정의역은 자판기의 버튼들, 공역은 음료수들이라고 생각해 봅시다. 버튼을 눌렀는데 음료수가 나오지 않으면 고장난 자판기인 것처럼, 모든 버튼에는 대응되는 음료수가 존재해야 합니다. 또 같은 버튼을 눌렀는데 어떨 땐 콜라가 나오고 어떨 땐 몬스터에너지가 나오면 그것도 제대로 된 자판기라고 보기 힘들겠죠? 그래서 한 버튼에는 오직 하나의 음료수만 대응되어야 하는 거예요.

그럼 다음 그림들을 보고 함수인지 함수가 아닌지 판단해 봅시다.

![b](https://user-images.githubusercontent.com/90246317/170730146-70d0556e-0918-45b8-b531-681b3dc214e6.png){: .align-center}

첫 번째 대응 관계는 함수입니다. 정의역 $$X$$의 모든 원소들이 공역 $$Y$$의 원소들과 대응 관계를 가지기 때문이지요. 정의역의 모든 원소는 대응관계를 가져야 하지만, 공역의 모든 원소가 대응관계를 가질 필요는 없습니다. 

두 번째 대응 관계는 함수가 아닙니다. $$X$$의 원소 $$2$$가 $$Y$$의 두 개의 원소와 대응하기 때문입니다. 공역의 오직 한 원소에만 대응되어야 한다는 두 번째 조건에 어긋나는 것입니다.

세 번째 대응 관계도 함수가 아닙니다. $$X$$에서 대응관계가 없는 원소가 존재하기 때문입니다.

네 번째 대응 관계는 함수입니다. $$X$$의 모든 원소들이 $$Y$$의 원소와 대응관계를 가지며, 하나의 $$X$$ 원소당 하나의 대응관계만 존재하기 때문입니다.

참고로, 공역에서 정의역의 원소들과 대응관계가 존재하는 원소들만 모은 집합은 **치역(Range)**이라고 합니다. 치역은 공역의 부분집합(Subset)이며, 공역과 치역이 항상 같지는 않다는 것도 알아둡시다.​

함수를 다음과 같은 형태로 표현할 수도 있습니다. 앞서 본 이항연산과 함수의 차이점은, **이항연산은 두 개의 입력을 요구하지만 함수는 하나의 입력만을 가진다**는 점입니다.

![b](https://user-images.githubusercontent.com/90246317/170730154-11375718-22d2-4082-9969-f9c9107ea976.png){: .align-center}

<br/><br/>

## 함수의 종류

정의역과 공역의 대응 형태에 따라 함수를 여러 종류로 구분할 수 있는데, 전사함수, 단사함수, 전단사함수 등의 분류가 있습니다.​

### 전사함수(Surjection)

전사함수는 공역의 모든 요소가 정의역에 대응되는 함수를 말합니다. 공역과 치역이 일치하는 함수라고 말하기도 합니다. 아래 함수는 전사함수입니다.

![image](https://user-images.githubusercontent.com/90246317/170730158-5ed9f52e-6fd4-4ba0-ab61-102f24285202.png){: .align-center}

### 단사함수(Injection, 일대일함수)

단사함수는 정의역과 공역의 요소가 일대일로 대응되는 함수를 말합니다. 다른 값을 넣으면 무조건 다른 결과가 나오는 함수라고 할 수 있지요. 아래 함수는 단사함수입니다.

![image](https://user-images.githubusercontent.com/90246317/170730161-2813c630-c9c7-471d-86de-2382b88882ec.png){: .align-center}


### 전단사함수(Bijection, 일대일대응)

**전단사함수는 전사함수이면서 단사함수인 함수를 말합니다.** 공역과 치역이 일치하고(모든 공역의 원소가 대응관계를 가지고) 정의역과 공역의 요소가 일대일로 대응되는 함수인 것이지요.

![image](https://user-images.githubusercontent.com/90246317/170730166-e500a811-b08a-4dbd-996d-c578d785516a.png){: .align-center}

<br/><br/>

## 이항연산을 함수로 나타낼 수 있을까?

이항연산은 두 개의 입력을 필요로 하지만, 함수는 하나의 입력만을 가진다고 했습니다. 그럼 이항연산을 함수로 나타낼 순 없는 걸까요?

**두 개의 입력을 하나의 입력으로 만들면 가능**합니다. $$a$$와 $$b$$라는 입력을 $$(a, b)$$라는 하나의 순서쌍으로 보는 것이지요. $$a$$와 $$b$$를 더하는 이항연산은 $$a + b$$ 중위표기법(Infix notation)을 통해 나타내지만, 함수처럼 전위표기법(Prefix notation)을 통해 $$+(a, b)$$으로 나타내고 $$+$$를 일반적으로 쓰이는 함수 이름인 $$f$$로 바꿔 보면, 이항연산 $$a+b$$는 $$f(a,b)$$로 표현할 수 있게 됩니다.

![b](https://user-images.githubusercontent.com/90246317/170730174-c3f2c15d-f347-41e7-a9ec-f381c6414c1f.png){: .align-center}

짜잔! 이렇게 이항연산을 함수처럼 만드는 것이 가능해졌습니다. 그럼 이항연산의 성질을 통해 이항연산을 다르게 해석한 함수들의 성질도 생각해 봅시다.

<div class="notice--primary" markdown="1">
💡 <u>교환법칙</u>

이건 쉽습니다. 우리가 더하기 함수 $$f$$를 "$$(a, b)$$를 넣으면 $$a + b$$를 내보내는 함수"로 정의했고, 유리수와 실수 $$a$$와 $$b$$에 대하여 $$a + b = b + a$$는 이미 만족되기 때문에 $$f(a, b) = f(b, a)$$임을 쉽게 알 수 있습니다.
</div>

<div class="notice--primary" markdown="1">
💡 <u>결합법칙</u>

세 유리수 또는 실수 $$a, b, c$$와 더하기 함수 $$f$$에 대하여 $$f(f(a, b), c) = f(a, f(b, c))$$가 성립하며, 유도 과정은 다음과 같습니다.
</div>

![b](https://user-images.githubusercontent.com/90246317/170730184-3a9ce678-7e8a-4ec9-913a-e1e6ff8a48a5.png){: .align-center} 

또, 세 유리수 또는 실수 $$a, b, c$$와 곱하기 함수 $$g$$에 대하여 $$g(g(a,b), c) = g(a, g(b, c))$$가 성립하며, 유도 과정은 다음과 같습니다.

![b](https://user-images.githubusercontent.com/90246317/170730196-043b1f3e-f84f-43c7-900d-168aa50b2a9f.png){: .align-center}

즉 이항연산에서 유리수와 실수가 만족했던 결합법칙을 더하기 함수와 곱하기 함수도 만족함을 알 수 있습니다!

<div class="notice--primary" markdown="1">

💡 <u>분배법칙</u>

세 유리수 또는 실수 $$a, b, c$$와 더하기 함수 $$f$$, 곱하기 함수 $$g$$에 대하여
$$g(f(a, b), c) = f(g(a, c), g(b, c))$$가 성립하고
$$g(c, f(a, b)) = f(g(c, a), g(c, b))$$가 성립하며, 유도 과정은 다음과 같습니다.
​
</div>

![d](https://user-images.githubusercontent.com/90246317/170730205-cc4cbe1a-84b5-4d83-90f4-29d5d9e80760.png){: .align-center}

좌분배법칙과 우분배법칙을 모두 만족하므로 더하기 함수와 곱하기 함수도 이항연산처럼 분배법칙을 만족한다고 할 수 있겠습니다.

<br/><br/>

## 합성함수(Composite function)

2개의 함수를 연쇄적으로 이어서 하나의 함수로 만드는 연산을 **함수의 합성(Function Composition)**이라 합니다. 함수 $$f$$와 $$g$$가 존재할 때, 둘을 합성한 함수 $$g \circ f$$는 함수 $$f$$의 출력을 함수 $$g$$의 입력으로 쓰게 됩니다. 잘 이해되지 않으니 그림으로 보도록 할게요.

![image](https://user-images.githubusercontent.com/90246317/170735145-3c438445-119b-43bf-967b-454c6bd4818c.png){: .align-center}

![b](https://user-images.githubusercontent.com/90246317/170730226-5b910be2-f613-43f0-bca6-48003bda3cf3.png){: .align-center}


이렇게 두 함수 $$f$$와 $$g$$를 합성하면, 중간 정거장 역할을 하는 집합 $$Y$$를 생략하고 $$X$$와 $$Z$$의 직접적인 대응 관계를 나타낼 수 있게 됩니다. 합성함수 $$g \circ f$$는 $$g(f(x))$$로도 표현하며, 오른쪽 함수부터 먼저 실행되는 점에 유의합시다.

또한, 여러 개의 함수들을 합성할 때, 함수의 합성을 이항연산으로 본다면 결합법칙이 성립합니다. 즉 $$h \circ (g \circ f)$$와 $$(h \circ g) \circ f$$의 결과는 같습니다.

![b](https://user-images.githubusercontent.com/90246317/170730243-ed7ef430-4ec9-4adb-9e86-3db59a04622e.png){: .align-center}

![b](https://user-images.githubusercontent.com/90246317/170730279-6a78b781-ee07-463f-a157-320539b79a37.png){: .align-center}

<br/><br/>

## 역함수(Inverse function)와 항등함수(Identity function)

수의 연산에서 다뤘던 역원과 항등원의 개념은 함수에서도 존재합니다.

### 역함수(Inverse function)

함수 $$f$$의 역함수는 $$f$$의 정의역과 공역을 뒤집은 함수이며, $$f^{−1}$$로 표기합니다. 함수 $$f$$의 역함수 $$f^{−1}$$가 존재할 경우, $$f$$의 정의역이 $$f^{−1}$$의 공역이 되고, $$f$$의 공역이 $$f^{−1}$$의 정의역이 됩니다.

![image](https://user-images.githubusercontent.com/90246317/170730295-cfc9ed3b-37e6-4d3f-8f26-a3a505d52307.png){: .align-center}

다만 **모든 함수가 역함수를 갖지는 않는데**, 정의역과 공역이 뒤바뀌는 특성 때문입니다. **$$f$$의 역함수가 존재하기 위한 필요충분조건은 $$f$$가 전단사함수여야 한다는 것**입니다. 다시 말해서 어떤 함수가 전단사함수면 반드시 역함수를 가지며, 어떤 함수의 역함수가 존재한다는 것은 그 함수가 전단사함수임을 의미합니다. 

왜일까요? 어떤 함수 $$f$$의 역함수 $$f^{−1}$$은 $$f$$의 정의역과 공역을 뒤집은 함수이기 때문입니다. $$f$$의 공역이 $$f^{−1}$$의 정의역이 되기 때문에, $$f^{−1}$$이 함수의 조건을 만족하려면 $$f$$의 공역의 모든 원소들이 정의역 원소들과 일대일로 대응되어야 하는 것이죠. 그리고 이는 곧 $$f$$가 전단사함수여야 한다는 말과 같은 것입니다.
​
​![b](https://user-images.githubusercontent.com/90246317/170730307-a5c098ad-1076-4adf-90d0-5f0504cc2358.png){: .align-center}

### 항등함수(Identity function)

**항등함수**란 정의역과 공역이 동일한 값으로 대응되는 함수입니다. 쉽게 말하면, $$x$$를 넣으면 $$x$$가 나오는 함수입니다.

항등함수는 기호 $$\text{id}$$로 나타냅니다.

![b](https://user-images.githubusercontent.com/90246317/170730315-19b10102-893c-4e1a-937f-e72dfeb4b816.png){: .align-center}

재미있는 것은, **역함수끼리 합성하면 항상 항등함수가 된다**는 사실입니다.

![b](https://user-images.githubusercontent.com/90246317/170730321-8221d2db-934d-437f-a2f4-f66442e3d122.png){: .align-center}

생각해보면 당연합니다. 함수 $$f$$는 $$x$$를 넣으면 $$y$$를 뱉는 함수고, $$f^{−1}$$은 $$y$$를 넣으면 $$x$$를 뱉는 함수니까요. 그래서 두 함수 $$f$$와 $$g$$를 합성해서 항등함수가 되었다는 것은, $$f$$와 $$g$$가 역함수 관계였다는 걸 의미하기도 합니다.

$$f(g(x)) = x$$이면, $$f^{-1}(x)=g(x)$$이고, $$g^{-1}(x)=f(x)$$인 것입니다.