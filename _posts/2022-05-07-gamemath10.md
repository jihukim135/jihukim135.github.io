---
title:  "[게임수학] 10. 내적(Dot product)의 기초"
excerpt: 1, 2차원에서 내적의 원리 이해하기 (+선형변환)

categories: ["Game Math"]
tags:
  # - [math]

toc: true
toc_sticky: true

date: 2022-05-07
last_modified_at: 2022-05-07

sidebar_main: true

---

> 학교 수업과 함께 '이득우의 게임 수학'을 공부하며 정리한 내용들입니다. [책 구매하러 가기!](http://aladin.kr/p/6fBSV)  
> 같은 카테고리의 앞선 글을 모두 읽었다고 가정하고 작성되었습니다.  
> 이해되지 않는 부분이 있다면 한번 읽고 와 보세요! 

## 내적(Inner product, Dot product)

**벡터의 내적(Inner product)**은 응용 측면에서 가장 중요한 연산으로, 게임 로직이든 셰이더든 안 쓰이는 곳을 찾기 힘듭니다. 내적에 대해 그 원리를 자세하게 설명하기 전에, 일단 무턱대고 내적의 공식부터 말하고 시작하겠습니다.

수치적으로 내적은 같은 차원의 두 벡터가 주어졌을 때 벡터를 구성하는 각 성분끼리 곱한 후 이들을 더해 스칼라를 만들어내는 연산이며, 곱셈 기호와 동일하게 가운뎃점($$\cdot$$ , Center dot)을 사용합니다. 그래서 내적을 **Dot product**라고 말하기도 합니다(이게 더 자주 쓰이는 듯합니다). 벡터 $$\vec{u}$$와 벡터 $$\vec{v}$$의 내적을 계산하는 수식은 다음과 같습니다.

$$
\vec{u}=(a,b)\\
\vec{v}=(c,d)\\
\vec{u}\cdot\vec{v}=a\cdot c+b\cdot d
$${: .align-center}

그리고 시각적으로 설명하면, $$\vec{u}$$와 $$\vec{v}$$의 내적을 구하는 작업은 **$$\vec{v}$$를 $$\vec{u}$$에 직교투영(Orthogonal Projection, 이하 ‘투영’)시킨 벡터의 길이를 구한 다음 $$\vec{u}$$의 길이를 곱해주거나, 반대로 $$\vec{u}$$를 $$\vec{v}$$에 투영시킨 후 $$\vec{v}$$의 길이를 곱해주는 연산**입니다. (사실 이건 정확한 설명은 아닌데, 투영된 벡터가 반대 방향을 가리킬 경우 음수가 나올 수 있기 때문입니다.) 그림을 통해 봅시다. 아래 그림에서, $$\vec{u}$$를 $$\vec{v}$$에 투영시켜 계산한 결과와 $$\vec{v}$$를 $$\vec{u}$$에 투영시켜 계산한 결과는 같습니다.

![1](https://user-images.githubusercontent.com/90246317/171493127-4887d6c8-679c-4524-890f-9d1cfd3dbe55.png){: .align-center}

또, 투영된 벡터가 다른 벡터와 반대 방향을 향할 경우 내적의 값은 음수가 됩니다.

![2](https://user-images.githubusercontent.com/90246317/171493145-5023cefa-5f8f-4f4c-97c9-470d3febe3b9.png){: .align-center}

그런데 지금까지 이런 계산의 과정을 지켜보면서, 내적은 그 원리를 알 수 없는 마법처럼 느껴집니다. 대체 각 성분끼리 곱해준 다음 더하는 작업이 왜 투영과 관련이 있는 것이며, 투영된 벡터가 반대 방향에 있으면 왜 음수값이 나오는 걸까요? 이제부터 그 이야기를 시작하려 합니다. (매우 긴 과정이 될 것입니다...)

<br/><br/>

## 1차원에서 내적의 원리 이해하기

일단 1차원에서부터 시작하겠습니다. 원점으로부터의 거리가 $$d$$인 점의 방정식을 세워봅시다. 매우 간단하게 생각하면 다음과 같이 $$x=-d,x=d$$라는 식을 세울 수 있습니다.

![3](https://user-images.githubusercontent.com/90246317/171493157-6ef917e8-0da0-40e0-9442-70c3e5dd70ae.png){: .align-center}

그런데 이 식은 $$-x=d,-x=-d$$로 세울 수도 있습니다.

![4](https://user-images.githubusercontent.com/90246317/171493166-7057de87-4f85-4229-b9aa-be6786c77de7.png){: .align-center}

검은색으로 쓴 식과 파란색으로 쓴 식이 동일하다고 생각되겠지만, 둘은 다르게 해석될 수 있습니다. 방향 개념을 포함한다면요. 지금부터는 $$x$$의 계수를 $$a$$라고 표시하고, $$a$$를 $$x$$의 방향으로 해석해볼 겁니다. 그러니까... 좀 와닿진 않지만, ‘$$x$$만의 수직선’이 존재한다고 생각해보는 겁니다.

![5](https://user-images.githubusercontent.com/90246317/171493193-2b40746a-2da7-4883-908d-cdb59216d509.png){: .align-center}

그리고 점의 방정식들을 같은 형태로 일반화하기 위해, 우변을 $$k$$로 맞춰주겠습니다.

![6](https://user-images.githubusercontent.com/90246317/171493220-45081264-1c9a-4438-b762-8f5ca07a3884.png){: .align-center}

이제부터는 $$x$$의 방향을 기준으로, 어떤 수가 $$x$$의 + 방향에 있으면 **‘$$x$$의 앞’**, - 방향에 있으면 **‘$$x$$의 뒤’**에 있다고 생각할 겁니다. 그리고 임의의 수 $$c$$가 $$x$$의 앞에 있는지 뒤에 있는지 판별해보려고 합니다. 먼저 $$a=1$$인 경우를 생각해봅시다. 그 중에서도 $$k=-d$$인 점부터 보겠습니다.

![7](https://user-images.githubusercontent.com/90246317/171493231-182992ae-0a9b-492a-a95e-8ef2a9a283d2.png){: .align-center}

여기서 앞뒤를 판별하는 가장 간단한 방법은, $$c-x_1$$의 부호를 알아보는 겁니다. $$c-x_1>0$$이면 $$c$$는 $$x_1$$의 앞에, $$c-x_1<0$$이면 $$c$$는 $$x_1$$의 뒤에 있습니다. ($$c-x_1=0$$이면 둘은 같은 위치에 있겠죠) $$a$$가 1이니까 $$x_1=ax_1$$이고 $$ax_1=k$$를 만족하므로, 위의 식에서 $$x_1$$을 $$k$$로 바꿔서,  $$c-k>0$$이면 $$c$$는 $$x_1$$의 앞에 있게 될 겁니다. $$c$$가 앞에 있는지 검사하는 판별식이 $$c-k$$가 되는 것입니다.

이제 $$k=d$$인 경우도 보겠습니다. 마찬가지로 여기서도 $$c-x_2>0$$이면 $$c$$는 $$x_2$$의 앞에 있습니다. $$x_2=ax_2=k$$이므로 이 경우에도 $$c-k$$ $$>0$$이면 $$c$$가 앞에 있게 됩니다.

![8](https://user-images.githubusercontent.com/90246317/171493240-cf34354b-d8f7-4ae6-9158-29f6f988d48c.png){: .align-center}

문제는 $$a=1$$인 경우입니다. $$x$$의 방향이 수직선의 방향과 반대가 되거든요. 여기서 조금 새로운 시각으로 $$a$$를 해석해봅시다. **$$a$$를 수직선에 대한 변환으로 보는 겁니다. 1차원이라서 변환이라는 용어를 쓰기 애매하긴 하지만**, 수직선 상의 모든 실수 $$x$$에 대해 $$ax$$는 $$x$$의 크기와 방향을 조절하는 역할을 합니다. 우리는 $$\rvert a \lvert =1$$인 경우만을 살펴보고 있으므로 $$a$$는 수직선에 있는 $$x$$들의 방향을 ‘그대로 두거나 뒤집는 작업’만을 진행할 겁니다. 그리고 $$a\cdot 0$$은 항상 $$0$$이 되므로, 원점에 위치한 점이 이동하지도 않습니다. 무슨 말이냐면 $$a$$는 벡터 공간의 선형변환과 그 성격이 꽤 유사하다는 겁니다. (나중에 2차원 공간에서의 내적을 보면 더 확실해집니다)

그러니 $$a=1$$일 때 모든 실수 $$x$$에 대해 $$ax$$는 수직선을 그대로 유지시키며, $$a=-1$$일 때 $$ax$$ 연산은 다음과 같이 $$c$$와 $$x_1$$를 포함한 실수들의 **부호, 즉 방향을 뒤집는** 효과를 냅니다. 

![9](https://user-images.githubusercontent.com/90246317/171493250-e895b5e2-51b2-44b5-96a4-caf3e33db3f7.png){: .align-center}

![10](https://user-images.githubusercontent.com/90246317/171493274-a6213e8c-c261-496f-a603-dc38924df817.gif){: .align-center}

![11](https://user-images.githubusercontent.com/90246317/171493282-49851cd0-c2bb-4179-922b-c01d1b400deb.png){: .align-center}

그리고 이렇게 $$ax$$ 연산을 진행해 수직선을 변환하고 나면, $$a=-1,k=d$$인 점 $$ax_1$$의 $$c$$에 대한 판별 방식은 $$a=1,k=d$$인 점 $$x_2$$의 그것과 매우 비슷해집니다.

![12](https://user-images.githubusercontent.com/90246317/171493306-41ccca0a-f222-4295-bb1c-b7d4968deeb7.png){: .align-center}

변환 전 $$c$$가 $$x_1$$의 앞에 위치했다면, 변환 후에도 $$c$$는 앞에 위치하기 때문에 $$ac-ax_1$$을 통해 $$c$$의 앞뒤를 검사할 수 있게 됩니다. $$ax_1=k$$이기 때문에 $$ac-k$$ $$>0$$이면 $$c$$가 앞에 있다고 판별할 수 있는 것입니다.

그리고 이런 식으로 생각해 보면 $$a=1$$일 때도 판별식을 구하는 과정에서 변환은 이미 일어났다고 볼 수 있습니다. 단지 ‘아무것도 하지 않는 변환’이기에 $$x$$와 $$ax$$가 같았을 뿐이죠. $$c$$도 그 대상에 포함되므로 아까 $$a=1$$일 때 세웠던 판별식들도 모두 $$c-k$$에서 <span style="background-color: #a0dfdb">$$ac-k$$</span>로 바꿀 수 있습니다.

마찬가지로 $$a=-1,k=-d$$인 경우에도 $$ax$$ 연산을 진행해주면 수들의 위치가(그러므로 $$x_2$$의 방향도) 뒤집어지기 때문에 판별식은 $$ac-ax_2=ac-k$$가 됩니다.

![13](https://user-images.githubusercontent.com/90246317/171493325-4a374eb1-9e28-4848-9f59-67e755e3d607.png){: .align-center}

그러므로 1차원 상에서 방향이 $$a$$이고 원점으로부터의 거리가 $$d$$인 모든 경우의 점들에 대해 다음이 성립합니다.

![14](https://user-images.githubusercontent.com/90246317/171493343-bdb50799-b77a-4093-87d8-bb62be8414ad.png){: .align-center}

여기서 점의 방정식들의 우변을 좌변으로 넘겨서 0으로 만들어 주고, $$ax-k=0$$은 연결 부호인 $$-$$를 고려하기 까다로우니 $$b=-k$$를 대신 대입해줍시다. 그러면 점의 방정식이 $$ax+b=0$$인 모든 점들에 대해 $$c$$가 앞에 있는지 판별하는 식은 <span style="background-color: #a0dfdb">$$ac+b$$</span>가 됩니다!

![15](https://user-images.githubusercontent.com/90246317/171493359-7c62ee2b-fc88-4234-9271-93e754a82d44.png){: .align-center}

그리고 지금까지는 $$ac+b$$의 부호만을 살펴봤는데, 당연하게도 $$ac-b$$는 점과 $$c$$ 사이의 거리 정보도 포함하고 있습니다. 애초에 $$ac+b$$는 $$ac$$에서 $$ax$$의 위치를 뺌으로써 유도되었습니다. 여기에 절댓값을 씌우면 당연히 두 점 사이의 거리가 됩니다. 의무교육 과정에서는 한 점에서 다른 점을 뺄 때면 절댓값을 씌워 거리만을 구했습니다. 하지만 절댓값을 씌우는 건 방향 정보를 버리는 행위였던 겁니다. 사실은 앞뒤를 판별할 수 있는 부호까지 포함하고 있었는데 말이에요!

그리고 이런 판별식을 구하기 위해 점의 방정식 $$ax+b=0$$을 세우는 방법은 다음과 같습니다.

1. 점의 방향이 수직선의 방향과 같으면 $$a=1,$$ 다르면 $$a=-1$$이다.
2. 점이 원점으로부터 떨어진 거리인 $$d$$에 대해, 점의 방향이 원점을 향하면 $$b=d,$$ 원점에서 멀어지면 $$b=-d$$이다.

이 규칙은 다음 그림만을 보고도 쉽게 파악할 수 있습니다.

![16](https://user-images.githubusercontent.com/90246317/171493375-f9c11027-5cdf-4952-98b2-47a65ca0b5df.png){: .align-center}

그럼 지금까지 알아낸 판별식을 통해서, $$x_1≤0≤x_2$$를 만족하는 두 점 $$x_1$$과 $$x_2$$에 대해 $$c$$가 그 사이에 있는지(경계 포함) 검사하는 방법을 생각해봅시다.

![17](https://user-images.githubusercontent.com/90246317/171493388-eb709fa3-6b58-4245-a883-2d0987d4858b.png){: .align-center}

가장 많이 쓰이는 방법은 $$x_1≤c≤x_2$$인지 검사하는 방법일 것입니다. 코드로 나타내면 이런 모습이겠죠.

```cpp
if (c >= x1 && c <= x2)
{
    // 조건에 맞으면 작업을 수행하는 코드
}
```

하지만 우리가 배운 방법을 통해 $$c$$의 앞뒤를 검사해도 됩니다. 일단 $$x_1$$과 $$x_2$$의 방향을 수직선과 일치하게 잡아준 다음 점의 방정식을 세워봅시다. (방향은 무엇으로 정하든 상관없습니다, 조건을 그에 따라 맞춰주면 됩니다)

![18](https://user-images.githubusercontent.com/90246317/171493412-7aeaa996-822a-4d9e-84a1-a853c58a953f.png){: .align-center}

그럼 $$c+d_1≥0$$이고 $$c-d_2≤0$$이면 $$c$$는 $$x_1$$과 $$x_2$$ 사이에 있게 될 겁니다. 두 판별식 중 하나는 양수, 하나는 음수가 되어야 하니까 둘을 곱하면 음수가 되어야겠죠? 그러니까 <span style="background-color: #a0dfdb">$$(c+d_1)(c-d_2)≤0$$</span>이면 $$c$$가 두 점 사이에 있다는 것입니다. 이걸 코드로 옮기면 이렇게 됩니다.

```cpp
if ((c + d1) * (c - d2) <= 0)
{
    // 조건에 맞으면 작업을 수행하는 코드
}
```

그런데 반대로 $$c+d_1<0$$이고 $$c-d_2>0$$이어도 두 판별식의 값을 곱하면 음수가 되지 않을까요? 걱정하지 않아도 됩니다. $$x_1≤0≤x_2$$인 경우 $$c+d_1<0$$과 $$c-d_2>0$$을 동시에 만족할 수는 없기 때문입니다.

![19](https://user-images.githubusercontent.com/90246317/171493432-7c2f67b4-e0d2-445a-9ff5-ee1c6598f0f0.png){: .align-center}

실제로 이 코드는 잘 동작합니다. 몇 개의 예시를 넣어 보면 알 수 있을 것입니다. 그런데 아직까지는 굳이 이렇게까지 해야 할까 싶은 의문이 듭니다. 이걸 2차원으로 확장해서 보면 그 의문을 해소할 수 있습니다.

<br/><br/>

## 2차원에서 내적의 원리 이해하기

일단 차원을 하나 올려봅시다. 1차원에서는 0차원에 해당하는 점의 방정식을 세웠었으니 2차원에서는 1차원에 해당하는 ‘직선의 방정식’을 세워볼 것입니다. 먼저 평면 상에 이런 직선이 있다고 칩시다.

![20](https://user-images.githubusercontent.com/90246317/171493459-45fd159f-745f-4644-a1e5-e00f0a6d845f.png){: .align-center}

보통은 직선의 기울기와 $$y$$절편을 이용해 $$y=mx+n$$ 꼴로 방정식을 세웁니다. 우변이 0인 형태로 식을 세워야 할 때도 있죠. 대표적으로 점과 직선 사이의 거리를 구할 때입니다.

![21](https://user-images.githubusercontent.com/90246317/171493470-85f95977-9aa3-41e8-86d7-0ec331e3b49b.png){: .align-center}

하지만 이 형태로 직선의 방정식을 세우면, 상수 $$a, b, c$$가 각각 무엇을 의미하는지 모호해집니다. 우리는 $$y=mx+n$$ 꼴에서 $$m$$이 직선의 기울기, $$n$$이 $$y$$절편을 의미한다는 것은 배웠지만, $$a, b,c$$를 해석하는 법은 배우지 않았거든요. 

그런데 잠깐 생각해 보면, $$ax+by+c=0$$이라는 식은 앞서 **1차원에서 세웠던 점의 방정식 $$ax+b=0$$과 그 형태가 굉장히 유사하다**는 걸 알 수 있습니다. 차원이 한 단계 올라갔을 뿐이죠. 이해를 돕기 위해 $$b$$를 우변으로 넘겨 보면, 방정식 $$ax=-b$$의 해는 **‘$$a$$에 의해 변환되면 $$-b$$가 되는 수 $$x$$’로 해석할 수 있었습니다**(위에서 익숙하게 봤던 $$ax=k$$의 $$k$$를 $$-b$$로 바꾼 것뿐입니다). 수직선 상에 찍은 점은 그 조건을 만족하는 $$x$$를 나타냈고요. 

그럼 직선의 방정식에서도 상수항인 $$c$$를 우변으로 넘겨 $$ax+by=-c$$로 만들어 보겠습니다. 그리고 마찬가지로 이 방정식의 해를 **‘$$\begin{bmatrix} a &b \end{bmatrix} \begin{bmatrix} x\\ y \end{bmatrix}$$라는 변환을 거치면 $$-c$$가 되는 $$x$$와 $$y$$’**로 해석해보면 어떨까요? 평면 상의 직선은 이 조건을 만족하는 $$x$$와 $$y$$로 구성된 벡터들이 모여 만든 것일테고요. 

실제로 $$\begin{bmatrix} a &b \end{bmatrix} \begin{bmatrix} x\\ y \end{bmatrix}$$는 행벡터와 열벡터의 원소 수가 일치해 행렬곱이 성립하고, $$ax+by$$로 계산되며, 이것은 $$(a, b) \cdot (x, y)$$라는 내적 연산의 결과와 일치합니다(!). (그리고 **$$\begin{bmatrix} a &b \end{bmatrix} \begin{bmatrix} x\\ y \end{bmatrix}$$는 정확히 $$(a,b)\cdot (x,y)$$의 행렬 표현이 맞습니다)**

하지만 $$\begin{bmatrix} a &b \end{bmatrix} \begin{bmatrix} x\\ y \end{bmatrix}$$가 무엇을 의미하는지는 궁금하지 않을 수 없습니다. 

일단 이 연산은 2차원 공간의 벡터 $$(x,y)$$를 입력으로 받아 스칼라 $$ax+by$$를 출력으로 내놓는 함수 $$f(x,y)=ax+by$$와 같습니다. 그리고 이 함수는, 2차원 공간 상의 벡터들을 1차원 수직선 상의 스칼라들에 대응시키는, 그러니까 **2차원 공간을 어떤 1차원 수직선으로 바꾸는** 변환으로 해석될 수 있습니다. 게다가 이 변환은 선형성을 만족합니다! 수치적으로 보죠.

<div class="notice--primary" markdown="1">
1. 가법성, Additivity (중첩성, Superposition): $$f(x_1+x_2)=f(x_1)+f(x_2)$$
    
    : $$f(x,y)=ax+by$$일 때, $$f(x_1+x_2, y_1+y_2)=f(x_1,y_1)+f(x_2,y_2)$$인가?
    
    (좌변) $$f(x_1+x_2, y_1+y_2)=a(x_1+x_2)+b(y_1+y_2)$$
    
    (우변) $$f(x_1,y_1)+f(x_2,y_2)=ax_1+by_1+ax_2+by_2=a(x_1+x_2)+b(y_1+y_2)$$
    
    ⇒ 만족!
    
2. 동차성, Homogeneity: $$f(kx)=kf(x)$$
    
    : $$f(x,y)=ax+by$$일 때, $$f(kx,ky)=kf(x,y)$$인가?
    
    (좌변) $$f(kx,ky)=akx+bky$$
    
    (우변) $$kf(x,y)=k(ax+by)=akx+bky$$
    
    ⇒ 만족!
</div>

그럼 2차원의 기저벡터 $$\hat{i}=(1,0)$$과 $$\hat{j}=(0,1)$$은 이 변환을 거쳐 어디에 도착할까요? $$\begin{bmatrix} a &b \end{bmatrix} \begin{bmatrix} 1\\ 0 \end{bmatrix}=a, \begin{bmatrix} a &b \end{bmatrix} \begin{bmatrix} 0\\ 1 \end{bmatrix}=b$$니까 각각 $$a$$와 $$b$$에 도착하게 됩니다! 두 기저벡터가 각각 수직선 위의 $$a$$와 $$b$$에 안착한다고 생각하면 됩니다. 그러니까 시각적으로 $$\begin{bmatrix} 1 &2 \end{bmatrix}\begin{bmatrix} x\\ y \end{bmatrix}$$라는 변환은 다음과 같은 모습이 되는 거죠. 선형변환이므로 $$x$$값(또는 $$y$$값)의 간격이 일정했던 벡터들은 변환 후에도 그 간격을 일정하게 유지합니다. 또 변환의 결과는 $$ax+by$$이므로 변환된 벡터들(스칼라들)의 위치는 $$L(\hat{i})=a$$와 $$L(\hat{j})=b$$에 의해 결정됩니다. 

![22](https://user-images.githubusercontent.com/90246317/171493516-69054df0-cd53-4f4a-8ae3-db814763e607.gif){: .align-center}

여기까지 이해했다면 이제 1x2 행렬에 의한 변환과 투영(Projection)과의 관계를 살펴볼 차례입니다. 

여기 크기가 1인 벡터 $$\vec{u}$$가 있습니다. 우리는 2차원 평면 상의 모든 벡터들을 $$\vec{u}$$를 지나고 $$\vec{u}$$와 같은 방향으로 뻗어나가는 직선에 투영하려고 합니다.

![23](https://user-images.githubusercontent.com/90246317/171493520-d083e149-b550-47ef-8d16-6b1fd385de86.png){: .align-center}

그런데 이렇게 생각해봅시다. 투영할 직선 위에, 수직선을 겹쳐놓는 겁니다! 원점은 2차원 평면과 같고, 방향은 $$\vec{u}$$와 같습니다. 물론 이 수직선은 벡터들과 다른 공간에 있으며, 수직선의 구성 요소들은 벡터가 아닌 수라는 걸 기억합시다.

![24](https://user-images.githubusercontent.com/90246317/171493538-ae897f49-75c6-431e-ac9d-b0cf3b8ad262.png){: .align-center}

그리고 벡터들이 직선 위로 투영될 때, **겹쳐진 수직선 위의 어느 수에 도착한다**고 생각하고, **벡터들을 그 위치(수)로 도착시켜 주는 선형변환**을 설계해보자는 겁니다.

![25](https://user-images.githubusercontent.com/90246317/171493613-6581e968-5036-49d3-b2fb-b55a81bb8a99.png){: .align-center}

그러려면 기저벡터 $$\hat{i}$$와 $$\hat{j}$$의 도착 위치만 알아내면 됩니다. 먼저 $$\hat{i}$$부터 살펴보죠.

<img src = "https://user-images.githubusercontent.com/90246317/171493644-dcff1477-916b-41ee-9f28-e54e9dc85f2e.png" width="70%">{: .align-center}

그런데 여기서 재미있는 것은, $$\vec{u}$$와 $$\hat{i}$$의 크기(다시 말하면, 겹쳐진 수직선에서의 수들의 간격과 벡터 공간의 $$x$$값들의 간격)가 완전히 일치하기 때문에, $$\hat{i}$$를 수직선에 투영해 만들어지는 수는 $$\vec{u}$$를 $$x$$축에 투영했을 때의 $$x$$좌표로 구할 수 있다는 겁니다. 

<img src = "https://user-images.githubusercontent.com/90246317/171493670-126bc5f4-feeb-4196-a66f-48612d06aa86.png" width="70%">{: .align-center}

그리고 이 부분이 말 그대로 **환상적인데**, 그 좌표는 그냥 **$$\vec{u}$$의 $$x$$좌표**입니다...

<img src = "https://user-images.githubusercontent.com/90246317/171493685-c38ecb8c-0d06-420b-9e48-20f21ec93a0c.png" width="70%">{: .align-center}

변환을 거친 $$\hat{j}$$값도 마찬가지로 **$$\vec{u}$$의 $$y$$좌표**와 일치합니다.

<img src = "https://user-images.githubusercontent.com/90246317/171493703-26a65cb9-bfcc-42bb-bf02-56123edee16e.png" width="70%">{: .align-center}

그러니까 이렇게 $$\vec{u}$$와 겹쳐진 수직선 위로 벡터들을 투영하는 변환의 행렬 표현은... $$\begin{bmatrix} u_x &u_y\end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix}$$로 설계되는 겁니다. (기가 막히고 너무 아름답지 않나요? 저는 그만 정신을 잃고 말았습니다...)

![30](https://user-images.githubusercontent.com/90246317/171493728-9744e9e5-d04d-4ae4-b8de-e9fed5113c27.png){: .align-center}

시각적으로, 벡터들이 $$\begin{bmatrix} u_x &u_y\end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix}$$라는 선형변환에 의해 $$\vec{u}$$와 겹쳐진 수직선 위로 스칼라화되어 도착하는 모습은 다음과 같습니다. 이건 **크기가 1인 $$\vec{u}$$에 대해** $$\begin{bmatrix} u_x &u_y\end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix}=\vec{u}\cdot (x,y)=u_xx+u_yy$$라는 내적 연산의 값의 크기가 왜 투영된 벡터의 크기를 의미하는지도, 결과값이 어떻게 음수가 될 수 있는지도 모두 설명해줍니다.

이 변환으로 만들어진 스칼라들의 크기는 **$$\vec{u}$$ 위의 직선에 투영된 벡터의 크기**와 같고,

$$\vec{u}$$의 방향을 기준으로 **반대 방향(즉,** $$\vec{u}$$의 **뒤)에 있었던 벡터라면 수직선의 0보다 작은 곳에 도착하니까 음수**가 나오는 겁니다.

![31](https://user-images.githubusercontent.com/90246317/171493788-bbe1d54c-282d-4700-a4e7-8e8cbcd41046.gif){: .align-center}

그리고 이건 크기가 1이 아닌 벡터 ($$\vec{w}$$라고 하겠습니다)와의 내적에 대해 왜 투영된 벡터의 크기에 $$\vec{w}$$의 크기가 곱해져야 하는지도 설명해줍니다. $$\vec{w}=k\cdot \vec{u}$$라 했을 때, $$\begin{bmatrix} w_x & w_y \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix}= \begin{bmatrix} k\cdot u_x & k\cdot u_y \end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix}$$이므로, 크기가 1인 벡터 $$u$$에 투영했을 때와 비교해 $$\hat{i}$$와 $$\hat{j}$$의 도착지점은 $$k$$배가 됩니다. 이는 벡터들이 투영되어 만들어진 스칼라들을 전체적으로 $$k$$배씩 스케일링해주는 효과를 냅니다.

![32](https://user-images.githubusercontent.com/90246317/171493792-8e1b041b-6a85-458a-80d3-4ee37d670425.gif){: .align-center}

정리해 봅시다.

<div class="notice--primary" markdown="1">
💡 크기가 1인 벡터 $$(a,b)$$와 $$(x,y)$$의 내적 $$(a, b)\cdot (x,y)=\begin{bmatrix} a & b \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix}=ax+by$$는

- $$(x,y)$$가 속한 공간의 기저벡터를 스칼라 $$a$$와 $$b$$로 만들어주는 선형변환과 같으며, 그 결과는 $$(x,y)$$가 변환되었을 때 수직선에서의 위치를 나타낸다.
- 벡터 $$(a,b)$$를 연장한 직선에 $$(x,y)$$를 투영시키는 작업이라 할 수 있으며, 연산 결과의 크기는 투영된 벡터의 크기, 부호는 $$(x,y)$$가 $$(a,b)$$의 앞에 있는지(+) 뒤에 있는지(-)를 나타낸다.

💡 크기가 1이 아닌 벡터 $$\vec{w}=(w_x,w_y)$$와 $$(x,y)$$의 내적은

- 위와 마찬가지로 기저벡터를 $$w_x,w_y$$로 만들어주는 선형변환과 같으며, 그 결과는 $$(x,y)$$가 변환되었을 때 수직선에서의 위치를 나타낸다.
- 벡터 $$(w_x,w_y)$$를 연장한 직선에 $$(x,y)$$를 투영시킨 후 $$\vec{w}$$의 크기만큼 스케일링해주는 작업이라 할 수 있으며, 연산 결과의 부호는 여전히 $$(x,y)$$가 $$(w_x,w_y)$$의 앞에 있는지(+) 뒤에 있는지(-)를 나타낸다.
</div>

<br/><br/>

## 다시 직선의 방정식으로...

길고 긴 이야기를 지나 드디어 직선의 방정식을 내적을 통해 이해할 차례가 되었습니다. 아까 봤던 $$ax+by+c=0$$ 형태의 식을 다시 보겠습니다. 그리고 $$a$$와 $$b$$로 구성된 벡터 $$(a,b)$$의 크기가 1이라고 가정하겠습니다.

![33](https://user-images.githubusercontent.com/90246317/171493803-8b3989e7-7093-4d63-985f-885cdb69a361.png){: .align-center}

이제는 위 사진의 질문에 답할 수 있습니다. 직선의 방정식 $$ax+by=-c$$의 해는, $$\begin{bmatrix} a & b \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix}$$ 라는 변환을 진행했을 때, 그러니까 크기가 1인 벡터 $$(a,b)$$를 연장한 직선에 $$(x,y)$$를 투영했을 때 겹쳐진 수직선 위에서 그 결과가 $$-c$$인 $$x$$와 $$y$$를 의미하며, 이를 구성 요소로 가지는 벡터들의 집합이 바로 저 직선인 것입니다!

<img src = "https://user-images.githubusercontent.com/90246317/171493851-3202d3dd-6967-414c-aa58-4a9ff76524c8.gif" width="70%">{: .align-center}

위에서 초록색 벡터들이 모여 형성한 직선의 방정식은 $$ax+by=-1$$인데, 이 벡터들의 공통점은 $$(a,b)$$에 투영하면 그와 겹쳐진 수직선 상에서 -1에 도착한다는 점입니다. 그러니까 $$ax+by+c=0$$은, **‘$$(a,b)$$에 직교투영된 벡터 $$(x,y)$$들이 수직선 상에서 $$c$$만큼 나아가면 원점에 도달함’**을 뜻하게 된다는 것입니다. 그렇다면, $$ax+by+c=0$$에서 **$$(a,b)$$는 직선의 방향**(직선을 기준으로 앞과 뒤를 구별할 수 있게 해주는 가이드!)으로, **$$c$$의 크기는 직선과 원점 사이의 거리**로 해석할 수 있습니다!

<div class="notice--primary" markdown="1">
💡 $$ax+by+c=0$$    $$\text{where} \ \lvert\lvert (a,b) \rvert\rvert =1$$

- $$(a,b)$$: 직선의 방향
- $$\lvert c \rvert$$: 직선과 원점 사이의 거리
</div>

이건 앞서 본 1차원에서 점의 방정식 $$ax+b=0$$과 그 원리를 공유합니다. 이 방정식에서 $$x$$는 $$a$$에 의해 변환된 후 $$b$$만큼 나아가면 원점에 도달하는 점을 뜻합니다. 2차원에서 직선의 방향 개념을 접하고 나니 모호했던 ‘점의 방향’이라는 말도 조금은 이해되지 않나요?

<div class="notice--primary" markdown="1">
💡 $$ax+b=0$$    $$\text{where}\ \lvert a\rvert =1$$

- $$a$$: 점의 방향
- $$\lvert b \rvert$$: 점과 원점 사이의 거리
</div>

이 원리는 특정 차원에만 한정되지 않기 때문에 평면의 방정식에 대해서도 다음이 성립합니다.

<div class="notice--primary" markdown="1">
💡 $$ax+by+cz+d=0 \ \text{where} \lvert \lvert (a,b,c) \rvert \rvert =1$$

- $$(a,b,c)$$: 평면의 방향
- $$\lvert d \rvert$$: 평면과 원점 사이의 거리
</div>

사실 미지수 $$x,y,z$$의 해를 구하는 데에는 이러한 형태의 방정식이 많이 사용되지 않습니다. 우리도 처음에 직선의 방정식을 세울 때 기울기와 $$y$$절편을 썼던 것처럼, 직선이 향하는 방향값을 구하는 작업이 직관적이지 않고 까다롭기 때문이지요. 하지만 게임 개발 과정에서 캐릭터가 향하는 방향은 대부분 금방 구할 수 있습니다. 엔진에서 그 방향 벡터를 예쁘게 정규화까지 해서 제공해주거든요(<span style="color:black">`forward`</span>). 원점으로부터의 거리만 구할 수 있으면, $$ax+by+cx+d=0$$꼴의 방정식을 세워 쉽게 직선이나 평면의 방정식을 알아내고 앞뒤 판별 등에 유용하게 사용할 수 있습니다.

그럼 일단 점의 방정식처럼 직선의 방정식 $$ax+by+c=0$$을 세우는 법을 생각해봅시다.

1. **직선이 바라보는 방향을 구한다**. ⇒ $$(a,b)$$
2. $$(a,b)$$의 **크기가 1이 아니면 정규화한다.** (정규화하지 않으면 원점으로부터의 거리로 상수항 $$c$$를 만들 수 없습니다. 투영된 벡터들이 스케일링되기 때문에 원점으로부터의 거리를 더하거나 빼줘도 수직선 상에서 0에 도달할 수 없게 되기 때문입니다)
3. $$(a,b)$$의 방향이 **원점을 향하면 원점으로부터의 거리에 $$+$$를, 원점에서 멀어지면 거리에 $$-$$를 붙여 상수항 $$c$$**를 만든다.

그럼 아까 봤던 직선을 통해 방정식을 완성해봅시다.

<img src = "https://user-images.githubusercontent.com/90246317/171493861-456be53e-6f7e-450f-ac24-60a9f6744ffb.png" width="70%">{: .align-center}

이 직선이 바라보는 방향은 $$(0.8,0.6)$$입니다. (+라고 써진 화살표의 방향입니다) 이 방향을 통해, + 방향에 속하는 영역에 있는 벡터는 직선의 ‘앞에 있음’, - 방향에 속하는 영역의 벡터는 직선의 ‘뒤에 있음’으로 판별할 수 있게 됩니다.

![36](https://user-images.githubusercontent.com/90246317/171493879-451757f4-6a7d-4477-b940-c7492ceb92b5.png){: .align-center}

다행히도 이 방향을 가리키는 벡터는 정규화가 되어있군요! 벡터의 크기가 $$\sqrt{0.64+0.36}=1$$이니까요.(사실 이 벡터의 크기(노름)를 피타고라스의 정리로 구하는 방법도 기하학적 도움을 빌려온 것뿐, 공리에서부터 만들어진 것은 아닙니다. 정확한 노름의 정의는 내적에 의해 설명되어야 합니다. 이건 다음 글에서 자세히 다루겠습니다.) 그럼 $$a=0.8, b=0.6$$이라 놓겠습니다. 그리고 여기서는 이 수들을 분수로 바꾸는 게 그닥 도움이 되지 않기 때문에 그대로 내버려 두겠습니다.

이제 $$0.8x+0.6y+c=0$$에서 남은 $$c$$만 구하면 됩니다. 이 직선은 원점으로부터 $$1$$만큼 떨어져 있는데, 직선의 방향이 원점을 향하고 있으니 $$c=+1$$이 되겠네요. 

![37](https://user-images.githubusercontent.com/90246317/171493893-9c7c5d0f-6096-4459-8646-85a14a84b21b.png){: .align-center}

와! 이렇게 직선의 방정식 $$0.8x+0.6y+1=0$$을 얻었습니다.

![38](https://user-images.githubusercontent.com/90246317/171493902-13155267-482c-4b07-b07d-af654c535b1b.png){: .align-center}

그리고 왜 이렇게 되는 건지 다시한번 생각해봅시다. 직선이 보는 방향 $$(0.8,0.6)$$과 겹쳐진 수직선의 방향은 같기 때문에, 직선의 방향이 원점을 향한다는 건 직선이 수직선 상의 음수에 투영된다는 걸 의미하고, 이 상태에서는 양수를 더해줘야 원점에 도달하니까 $$c>0$$ 이어야 하는 겁니다. 

![39](https://user-images.githubusercontent.com/90246317/171493917-5bf86bc0-d9f1-4bf5-8765-6b8a6762091e.png){: .align-center}

만약 직선의 방향이 원점에서 멀어지고 있다면, 그건 직선이 수직선의 양수에 투영된다는 뜻이고 그 상태에서는 음수$$(c<0)$$를 더해줘야(거리만큼을 빼 줘야) 원점에 도달하게 되겠죠.

![40](https://user-images.githubusercontent.com/90246317/171493938-c9a1b8b4-26e6-474e-b504-d9bb08b5c0bf.png){: .align-center}

직선의 방향이 정반대일 때도 마찬가지입니다. 만약 방향이 $$(-0.8,-0.6)$$이 된다면, $$(-0.8,-0.6)\cdot (x,y)$$는 기저벡터 $$\hat{i}$$와 $$\hat{j}$$를 각각 $$-0.8$$과 $$-0.6$$에 도착시키는 작업이며 이는 위에서 봤던 수직선을 뒤집은 후 이에 벡터들을 투영시킨 값을 얻는 것과 같은 효과를 냅니다. 그러니까 직선이 보는 방향과 같은 방향의 수직선을 겹친다고 생각하면 됩니다. 여기서도 마찬가지로 직선이 음수에 투영되면 직선의 방향은 원점에서 멀어지는 모습이 되고, 양수에 투영되면 원점을 향하는 모습이 되므로 그에 따라 상수항 $$c$$의 부호가 결정되는 것입니다.

![41](https://user-images.githubusercontent.com/90246317/171493964-9a04e22c-63e3-4a05-96cd-0d4ad3036755.png){: .align-center}

<br/><br/>

## 직선과 선분의 교차 판별 수식

지금까지 알아본 내용을 응용해 직선과 선분이 교차하는지 알아보는 판별식을 세울 수 있습니다. 먼저 그 전에 직선에 대해 어느 벡터가 앞에 있는지 뒤에 있는지 판별하는 법을 생각해봅시다. 이건 직선의 방향을 수직선의 방향으로 생각하면 쉽습니다. 예를 들어 방정식 $$-0.8x-0.6y-1=0$$로 만들어지는 직선은 $$\begin{bmatrix} -0.8 &-0.6 \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix}$$를 거치면 1이 되는 벡터들의 모임이니까, 어떤 벡터가 같은 변환을 거친 후 1보다 커지면 이 직선의 앞에, 1보다 작아지면 이 직선의 뒤에 있게 될 것입니다. $$-0.8x-0.6y>1$$인 $$x$$와 $$y$$로 이루어진 벡터라면 직선의 앞에 있게 되는 거죠. 여기서 우변을 0으로 정리해 주면, 판별식은 $$-0.8x-0.6y-1$$, 일반화하면 $$ax+by+c$$가 될 겁니다. 결론적으로 어떤 직선의 방정식 $$ax+by+c=0$$와 $$\vec{v}=(v_x,v_y)$$에 대해, <span style="background-color: #a0dfdb">$$av_x+bv_y+c>0$$</span>이면 $$\vec{v}$$는 직선의 앞에 있게 됩니다.

직선과 선분이 교차하려면, 선분의 한쪽 끝은 직선의 뒤에 있고 한쪽 끝은 직선의 앞에 있어야겠죠. 그러니까 선분의 양쪽 끝을 나타내는 벡터가 각각 $$v_1=(x_1,y_1), v_2=(x_2,y_2)$$일 때, <span style="background-color: #a0dfdb">$$(ax_1+by_1+c)(ax_2+by_2+c)≤0$$</span>이면 선분은 직선과 교차하게 될 겁니다. (등호가 붙은 이유는 선분의 한쪽 끝이나 양쪽 끝이 직선 위에 있는 경우를 포함했기 때문입니다. 등호를 포함시킬지 말지는 상황과 목적에 따라 정하면 됩니다)

<br/><br/>

## 사용된 툴과 자료들

- 이득우의 게임수학

- [2D linear transformation](https://www.desmos.com/calculator/upooihuy4s?lang=ko)

- [Essence of linear algebra](https://youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab)