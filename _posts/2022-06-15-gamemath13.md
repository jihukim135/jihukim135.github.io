---
title:  "[게임수학] 13. 월드/로컬 공간, 렌더링 파이프라인(Rendering pipeline)"
excerpt: 트랜스폼(Transform), 모델링 행렬(Modeling matrix)

categories: ["Game Math"]
tags:
  # - [math]

toc: true
toc_sticky: true

date: 2022-06-15
last_modified_at: 2022-06-15

sidebar_main: true

---

## 월드 공간(World space)과 로컬 공간(Local space)

현실 세계에서는 물체 스스로가 회전하지만, 가상 세계에서는 아닙니다. 2차원 공간의 회전 변환을 생각해봅시다. 이 변환이 물체를 회전시키는 방법은 단순하게도 해당 공간에 있는 원소(벡터)들을 모두 회전시켜버리는 것입니다. 그러니까 가상 세계에서는 엄밀히 말하면 물체가 아니라 공간이 회전한다는 이야기입니다. 이건 회전 변환뿐만 아니라 다른 선형변환들에게도 마찬가지로 적용됩니다.

공간에 오로지 하나의 물체만 존재할 때 이런 선형변환의 성질은 크게 문제되지 않습니다. 하지만 게임은 물론이고 대부분의 콘텐츠는 물체 하나로만 구성되지 않죠. 만약 한 공간에 여러 개의 물체가 존재한다면 특정 물체만 회전시키는 것이 곤란해집니다. 같은 공간에 있는 다른 물체들도 같이 회전해버릴 테니까요.

![한공간회전](https://user-images.githubusercontent.com/90246317/176607511-39b840da-26a0-4700-a518-dc25b2ef2b2d.gif)

각각의 물체를 따로 변환시키려면(크기, 회전, 이동) 어떻게 해야 할까요? 물체마다 고유의 공간을 가지고 있으면 됩니다. 그러니까 위에 보이는 저 세 개의 사각형이 각자의 공간을 가지는 겁니다. 그리고 그 공간들을 겹쳐 놓으면 각각의 물체에 대해 따로 변환을 적용하는 것이 가능해집니다.

![여러공간회전](https://user-images.githubusercontent.com/90246317/176607564-ff0e293a-9862-41d0-a0e4-5d6d47f6d8f2.gif)

한 가지 더 알아야 할 것은, 물체는 자신의 공간이 어떻게 변환되는지를 감지하지 못한다는 점입니다. 그 공간 안의 모든 요소들이 함께 선형적으로 움직이니까요. 첫 번째 GIF에서 우리가 주황색 사각형이라면, 자신이 속한 공간이(그러므로 자신도) 회전하고 있다는 걸 인지하지 못할 것입니다.

그러니까 어떤 공간(물체)의 변환을 감지하기 위해서는 최소 두 개의 공간이 필요합니다. 물체의 공간과 관찰자의 공간이죠. 전자는 앞서 설명했듯이 **물체가 각자 가지는 자신만의 고유한 공간**입니다. 이를 우리는 **로컬 공간(Local space)**이라 부르기로 했습니다. 그러면 **모든 물체들의 변화를 감지할 수 있는 하나의 공간**이 또 필요합니다. 물체들이 모이는 중앙 광장 역할을 하는 공간 말입니다. 이를 우리는 **월드 공간(World space)**이라고 부릅니다.

이해를 돕기 위해 쉬운 예를 들어보겠습니다. 어릴 적 놀이터에 있었던 이 기구를 기억하시나요? (지금도 있는지는 모르겠네요) 저도 이번에 처음 알았는데 뺑뺑이로 불렀던 이것의 정식 명칭은 회전무대라고 합니다. ([이미지 출처](https://www.lafent.com/mtrial/mtr_view.html?idx=1298))

![Untitled](https://user-images.githubusercontent.com/90246317/176607587-e1964c3d-92f1-4204-8a0c-19a2130c2268.png){: .align-center}

회전무대에 여러 친구들과 함께 올라가서 빙빙 돈다고 생각해봅시다. 그러면 내 입장에서는 회전무대와 친구들이 멈춰있는 것처럼 보일 것입니다. (대신 세상이 도는 것처럼 보이겠죠) 하지만 밖에서 관찰하고 있는 친구의 입장에서는 회전무대와 여러 명의 친구들이 빙글빙글 도는 게 보일 겁니다.

여기서 회전무대와 거기 올라탄 친구들은 회전무대의 로컬 공간에, 밖에서 관찰하는 친구는 월드 공간에 있다고 생각하면 됩니다. 회전무대에 올라탄 친구들은 같은 공간에 있는 물체의 회전을 감지하지 못합니다. 하지만 다른 공간에 있는 것들(회전무대를 제외한 세상)이 움직이는 것은 볼 수 있겠죠. 마찬가지로 밖에 있는 친구는 아예 다른 공간에 속해있기 때문에 회전무대와 아이들이 도는 걸 볼 수 있는 것입니다.

아무튼 우리가 지금까지 다뤘던 아핀 공간은 로컬 공간에 해당했습니다. 로컬 공간은 물체 또는 메시의 공간이자, 모델링 프로그램의 공간입니다. 이런 다수의 물체들을 담는 공간, 즉 게임 엔진에서의 씬(월드, 레벨, 스테이지)이 월드 공간에 해당합니다. 당연하게도 씬은 하나만 존재해야 하겠죠!

![Untitled](https://user-images.githubusercontent.com/90246317/176607611-e0762e3a-a0ba-4819-b466-c67b1b8d8733.png){: .align-center}

위 사진은 유니티에서 대충 큐브 몇 개를 올려 만든 씬의 모습입니다. 기즈모들의 모양을 보면 짐작할 수 있듯이(단, 좌표계가 Local로 세팅된 상태입니다) 이 큐브(게임오브젝트)들은 각자의 로컬 공간을 가지고 있으며, 전체적으로는 하나의 월드 공간과 로컬 공간들이 중첩되어 있습니다.

사실 지금까지 선형변환을 이해하기 위해 사용했던 시각적 자료에도 월드 공간이 들어있습니다. x축과 y축으로 고정된 배경의 공간이 그것입니다. 

![Untitled](https://user-images.githubusercontent.com/90246317/176607632-8a8bb5ba-aff8-40fc-affb-5dc58fe56fd1.png){: .align-center}

그런데 이렇게 물체를 월드 공간에 올리려면, 물체가 **월드 공간 기준으로** 어디에 위치하며 얼만큼 스케일링되었고 얼만큼 회전한 상태인지를 나타내는 값들을 정해줘야 합니다. 이걸 물체의 **트랜스폼(Transform)**을 설정한다고 이야기합니다. 그럼 트랜스폼에 대해 자세히 알아보겠습니다.

<br/><br/>

## 트랜스폼(Transform)

씬에 올라가는 물체(유니티에서는 게임오브젝트GameObject, 언리얼 엔진에서는 액터Actor라고 부릅니다. 여기서는 게임오브젝트라는 용어를 사용하겠습니다)들은 공통적으로 반드시 트랜스폼을 가지고 있어야 합니다. 일반적으로 게임 엔진에서 트랜스폼이 없는 게임오브젝트는 정의되지 않습니다. 모든 콘텐츠들은 월드 공간 안에 존재해야 하기 때문입니다. 

트랜스폼은 **위치, 회전, 크기** 정보로 이루어집니다. 만약 씬이 2차원이라면 트랜스폼은 다음과 같이 다섯 개의 스칼라 데이터로 구성될 것입니다.

<div class="notice--primary" markdown="1">
💡 2차원 월드 공간에서 물체의 트랜스폼

크기($$S$$): $$(s_x,s_y)$$

회전($$R$$): $$\theta$$

이동($$T$$): $$(t_x,t_y)$$

</div>

다음은 유니티와 언리얼 엔진에서 보여지는 트랜스폼의 모습입니다. 위와 달리 3D 기준이라 아홉 개의 스칼라값으로 구성되어 있네요.

![Untitled](https://user-images.githubusercontent.com/90246317/176607659-556f3516-f116-46ef-bce6-0a6d32b34c83.png){: .align-center}

아무튼 다시 2차원으로 돌아와서, 이 단순한 트랜스폼의 데이터들은 크기, 회전, 이동에 대한 세 가지 아핀변환 행렬에 대응됩니다. 이 행렬 데이터들을 모두 저장해두는 것보다, 다섯 가지 단순한 데이터들을 저장해두는 것이 메모리 관리에 효율적일 것입니다. 어차피 행렬들을 만드는 방법은 정해져 있으니까요.

$$
S=\begin{bmatrix} s_x &0 &0 \\
0 &s_y &0 \\
0 &0 &1 \end{bmatrix} \\
R=\begin{bmatrix} \cos\theta &-\sin\theta &0 \\
\sin\theta &\cos\theta &0 \\
0 &0 &1 \end{bmatrix} \\
T=\begin{bmatrix} 1 &0 &t_x \\
0 &1 &t_y \\
0 &0 &1 \end{bmatrix}
$$

개발자가 스크립팅 로직에서 다섯 가지 데이터를 사용해 게임오브젝트를 배치하더라도 렌더링 로직에서는 위의 아핀변환 행렬들을 결합해 사용하게 됩니다. 메시의 구성 요소들이 화면의 픽셀로 보여지기 위해서는 여러 변환 과정을 거쳐야 하므로 행렬곱을 통한 최적화가 필수적으로 요구되기 때문입니다. 이렇게 세 가지 아핀 변환 행렬을 결합해 만든, 렌더링 파이프라인에서 사용하는 행렬을 **모델링 행렬(Modeling matrix)**이라 합니다. 스크립팅 코드에서 수치로 설정된 트랜스폼은 렌더링 로직에서 모델링 행렬로 변환됩니다. 그러니까 네이티브 코드에서는 모델링 행렬이 사용된다는 이야기입니다.

<br/><br/>

## 모델링 행렬(Modeling matrix)

그럼 모델링 행렬에 대해 자세히 알아보겠습니다. 세 개의 행렬을 결합할 때 주의할 점은, 행렬곱은 교환법칙이 성립하지 않는다는 점입니다. 그러니까 어떤 순서로 세 개의 행렬을 결합하느냐에 따라 결과가 달라질 수 있습니다. 그러니 다음 6가지 경우의 수 중에서 우리가 의도한 결과를 만들어내는 순서를 선택해야 할 것입니다. 

$$
T\cdot S\cdot R \\
T\cdot R\cdot S \\
R\cdot S\cdot T \\
R\cdot T\cdot S \\
S\cdot R\cdot T \\
S\cdot T\cdot R
$$

그럼 차근차근 생각해봅시다. 먼저 크기변환($$S$$)와 회전변환($$R$$)중 어느 변환이 먼저 일어나야 할지 알아보겠습니다. 아래 두 가지 중 어느 순서가 적절할까요? 물론 첫번째 경우일 것입니다. 두 번째 경우처럼 먼저 회전시킨 다음 크기변환을 적용하면, 의도했던 직사각형의 모습이 변형되어 버립니다. 회전변환은 강체변환입니다. 그러므로 물체의 모습을 바꿀 수 있는 기회는 회전변환을 적용하기 전에만 있습니다. 크기변환으로 물체의 모습을 확정짓고 나서야 안심하고 강체변환을 적용할 수 있는 것입니다.

![Untitled](https://user-images.githubusercontent.com/90246317/176607676-87218295-b777-4e11-b90e-6ab66b5765c2.png){: .align-center}

다음으로 회전변환($$R$$)과 이동변환($$T$$) 중 어느 것이 먼저 적용되어야 할지 보겠습니다. 아래 그림을 보면, 당연하게도 첫 번째 경우처럼 회전을 먼저 시킨 다음 물체를 이동시키는 게 적절함을 알 수 있습니다. 이동 다음에 회전을 적용시키면, 물체의 위치가 바뀐 상태에서 공간 전체가 회전하게 되어 위치가 의도한 것과 달라지게 됩니다. 회전변환은 회전만 수행해야 하는데 위치가 바뀌어버리는 것입니다.

![Untitled](https://user-images.githubusercontent.com/90246317/176607698-ebd79adc-311e-46c7-93ef-1caad357d589.png){: .align-center}

그리고 이동변환 또한 (아핀 공간에 한해)강체변환이므로 크기변환은 이동과 회전변환 전에 이루어져야 합니다. 그러면 행렬의 적용 순서는 $$S$$ → $$R$$ → $$T$$가 되어야 한다는 결론이 나옵니다. 수식으로 나타내면 $$T\cdot R\cdot S$$가 되겠네요. 순서가 정해졌으니 행렬곱으로 모델링 행렬을 생성해봅시다. 트랜스폼 정보 $$(s_x,s_y),\theta,(t_x,t_y)$$로 만들어지는 모델링 행렬 $$M$$은 다음과 같습니다.

$$
M=T\cdot R\cdot S=\begin{bmatrix} 
\cos\theta \cdot s_x& -\sin\theta\cdot s_y & t_x \\
\sin\theta\cdot s_x & \cos\theta\cdot s_y & t_y \\
0 & 0 & 1
\end{bmatrix}
$$

모델링 행렬은 월드 공간을 기준으로 물체가 가진 공간의 상대값을 확정하는 역할을 합니다. 월드 공간에서 게임 콘텐츠가 만들어지기 때문에 월드 공간의 원점을 기준으로 모든 물체의 트랜스폼이 해석되어야 하는 것입니다.

<br/><br/>

## 로컬 축(Local axis)

물체를 자신이 바라보는 방향 기준으로 움직이기 위해서는 물체가 바라보는 방향의 정보, 즉 로컬 공간의 기저 정보가 필요합니다. 로컬 공간을 구성하는 기저벡터들을 정규화한 것을 **로컬 축(Local axis)**이라 합니다. 단, 여기서 로컬 공간은 아핀 공간임을 기억합시다. 반대로 월드 공간을 구성하는 표준기저벡터들은 **월드 축(World axis)**가 되겠네요.

![Untitled](https://user-images.githubusercontent.com/90246317/176607711-5cd76c74-9926-4a74-a6bb-5bca34316d94.png){: .align-center}

로컬 축을 월드 축과 비교하기 위해, 다음과 같이 로컬 축들에 이름을 붙이기도 합니다.

| 로컬 축 | 이름 |
| --- | --- |
| $$+x$$ | 라이트벡터(Right Vector) |
| $$+y$$ | 업벡터(Up Vector) |
| $$+z$$ | 포워드벡터(Forward Vector) |

로컬 축은 월드 좌표계 기준으로 로컬 기저벡터들의 값을 정규화해 저장한 정보입니다. 모든 물체는 아핀 공간에 존재하고, $$n$$차원에서 $$n$$번째 기저벡터를 제외한 나머지 기저벡터들은 $$n$$번째 차원 값이 $$0$$이므로 아핀공간의 벡터로 해석할 수 있습니다. 즉 로컬 축은 방향 정보만을 가지며 월드 공간 기준의 시점과 종점 정보는 저장되지 않습니다. 그러니까 물체의 이동과 크기 정보가 변하더라도 회전변환이 일어나지 않는 이상 로컬 축의 값은 유지된다는 뜻입니다.

로컬 축 정보를 따로 저장해둘 필요는 없는데 각을 통해 간단하게 로컬 축을 생성할 수 있기 때문입니다. 월드 공간 기준으로 $$\theta$$만큼 회전해있는 트랜스폼의 로컬 축은 $$(\cos\theta, \sin\theta),(-\sin\theta,\cos\theta)$$가 됩니다. 

그런데 이들은 회전행렬을 구성하는 2차원 기저벡터들과 같기 때문에, 로컬 $$x$$축을 $$\vec{r}=(r_x,r_y)$$, 로컬 $$y$$축을 $$\vec{u}=(u_x,u_y)$$로 놓으면 회전 행렬을 다음과 같이 표현할 수 있습니다. 

$$
R=\begin{bmatrix} r_x & u_x & 0 \\
r_y & u_y & 0 \\
0 & 0 & 1 \end{bmatrix}
$$

그럼 다음과 같이 로컬 축 정보로 모델링 행렬을 구성하는 것이 가능해집니다.

$$
M=\begin{bmatrix} 
r_x \cdot s_x& u_x\cdot s_y & t_x \\
r_y\cdot s_x & u_y\cdot s_y & t_y \\
0 & 0 & 1
\end{bmatrix}
$$

<br/><br/>

## 예제: 사각형의 트랜스폼과 아핀 공간의 변화

여기 한 변의 길이가 1인 정사각형이 있습니다. 이 정사각형은 3차원 벡터 공간의 2차원 아핀 공간에 놓여 있습니다. 이 사각형이 다음과 같은 트랜스폼을 가지고, $$M=T\cdot R\cdot S$$의 순서대로 변환될 때 사각형의 벡터 공간과 아핀 공간이 어떻게 변하는지 살펴보겠습니다.

- 위치: $$(1,1)$$
- 회전: $$\frac{\pi}{4}$$
- 크기: $$(1.5, 1)$$

![Untitled](https://user-images.githubusercontent.com/90246317/176607734-23cbb0e8-861a-4315-a212-b0295d96cc77.png){: .align-center}

먼저 크기변환행렬 $$S=\begin{bmatrix} 1.5 & 1 &0 \\
1.5 & 1 & 0 \\
0 & 0& 1 \end{bmatrix}$$ 를 적용시켜 보면, 벡터 공간의 기저벡터였던 $$\hat{i}=(1,0,0)$$이 $$(1.5, 0, 0)$$으로 변합니다. 그에 따라 벡터 공간과 아핀 공간은 모두 가로로 $$1.5$$배 늘어나게 됩니다. 

![Untitled](https://user-images.githubusercontent.com/90246317/176607750-f302ebc4-1fe2-406f-9ad9-61c9088aa9b1.png){: .align-center}

그 다음 회전변환행렬 $$R=\begin{bmatrix} \cos\frac{\pi}{4} & -\sin\frac{\pi}{4} & 0 \\ \sin\frac{\pi}{4} & \cos\frac{\pi}{4} & 0 \\ 0 & 0 & 1 \end{bmatrix}$$로 사각형을 45도 회전시켜보겠습니다. 그러면 $$\hat{i}$$는 $$(1.5\cos\frac{\pi}{4}, 1.5\sin\frac{\pi}{4})$$, $$\hat{j}$$는 $$(-\sin\frac{\pi}{4}, \cos\frac{\pi}{4})$$가 되며 사각형의 벡터 공간 전체가 45도 회전하게 됩니다.

![Untitled](https://user-images.githubusercontent.com/90246317/176607763-1b22f6d5-67b4-4c67-8a5e-6ef1ca87f7b8.png){: .align-center}

마지막으로 이동변환 행렬 $$T=\begin{bmatrix} 1 & 0 & 1 \\ 0 & 1 & 1 \\ 0 & 0 & 1 \end{bmatrix}$$를 곱해보겠습니다. 그러면 다음과 같이 $$\hat{k}$$가 $$(1,1,1)$$이 되며, $$z=1$$인 아핀 공간은 정확히 $$x$$축 방향으로 1만큼, $$y$$축 방향으로 1만큼 밀려나게 됩니다.

![Untitled](https://user-images.githubusercontent.com/90246317/176607774-98c7f6eb-8de7-4ba3-9551-7d2ba45e8b9e.png){: .align-center}

그러면 변환된 벡터 공간의 기저벡터를 행렬로 나타내 보겠습니다.

$$
\begin{bmatrix}
1.5\cos\frac{\pi}{4} & -\sin\frac{\pi}{4} & 1 \\
1.5\sin\frac{\pi}{4} & \cos\frac{\pi}{4} & 1 \\
0 & 0 & 1 \end{bmatrix}
$$

그리고 이건 모델링 행렬 $$M=\begin{bmatrix}
\cos\theta \cdot s_x& -\sin\theta\cdot s_y & t_x \\
\sin\theta\cdot s_x & \cos\theta\cdot s_y & t_y \\
0 & 0 & 1
\end{bmatrix}$$과 표준기저벡터들의 행렬 $$\begin{bmatrix} 1 &0 &0 \\ 0 &1 &0 \\ 0 & 0 &1 \end{bmatrix}$$을 곱한 값과 같습니다. 표준기저벡터들의 행렬은 항상 항등행렬이므로 그냥 모델링 행렬이라 봐도 무방하겠네요.

아핀 공간만 보면 다음과 같은 모습입니다.

![Untitled](https://user-images.githubusercontent.com/90246317/176607826-3688cec3-1720-4832-8d0e-1cb4d2f7372f.png){: .align-center}

<br/><br/>

## 렌더링 파이프라인(Rendering pipeline)

게임 로직에서는 현재 프레임에서의 게임오브젝트들이 가지는 트랜스폼 값을 확정합니다. 트랜스폼의 read/write가 가능한 것입니다. 그러나 렌더링 로직에서는 앞서 게임 로직에서 트랜스폼이 확정되었다고 보기 때문에 write할 수 없도록 트랜스폼을 읽기 전용으로 막아둡니다. 

렌더링 로직은 일반적으로 GPU가 처리하는데, 각 게임오브젝트가 가지는 메시의 로컬 공간의 버텍스 정보를 월드 기준으로 변환하고, 몇 가지의 정해진 과정을 더 거쳐서 화면에 띄웁니다. 이 몇 가지의 과정, 즉 게임오브젝트를 렌더링하기 위해 GPU가 거치는 일련의 절차를 **렌더링 파이프라인(Rendering pipeline, Graphics pipeline)**이라고 합니다. 

![Untitled](https://user-images.githubusercontent.com/90246317/176607854-e7a09102-d403-4fc4-b404-9f8061eab6d1.png){: .align-center}

위 사진은 위키피디아에서 긁어온 것인데 굉장히 복잡해 보이죠? 그래서 아주 단순화시켜 보았습니다.

![Untitled](https://user-images.githubusercontent.com/90246317/176607883-7159e856-0ebd-4758-be7d-14bbde827249.png){: .align-center}

이렇게 단순화시킨 렌더링 파이프라인에서 가장 핵심적인 부분은 볼드체로 표시된 **Vertex shader, Rasterizer, Pixel shader**입니다. Pixel shader는 **Fragment shader**라 부르기도 합니다.

또 Vertex shader와 Pixel shader 단계는 DirectX와 OpenGL의 3차원 표준 렌더링 파이프라인에서 프로그래밍이 가능한 부분입니다. 그러니까 저 단계에 진행되는 작업은 어떤 함수를 통해 이루어지는데 그것이 셰이더(Shader)이고, Vertex/Pixel shader도 그 중 하나라는 것입니다.

일단 하나하나씩 간단히 소개하겠습니다. Input assembler(줄여서 IA, OpenGL에선 Vertex puller)는, 간단히 말하면 정점 정보를 모아서 Vertex shader에게 넘겨주는 역할을 합니다. IA는 메시의 정점 버퍼와 인덱스 버퍼 등을 입력으로 받아서 다른 파이프라인 단계에서 사용될 기본 도형(Primitive, 점/선/삼각형 등)을 구성합니다.

다음으로 Vertex shader에서는 정점 정보들을 받아서 이들을 **메시의 로컬 공간에서 월드 공간으로**, 카메라 공간에서 **클립 공간(Clip space)**으로 변환하는 작업을 수행합니다. 이 과정은 **결합된 행렬을 통해 진행**되며 2D에서는 더 단순해질 수 있습니다(카메라 공간과 클립 공간은 여기서는 자세히 설명하지 않겠습니다). 아무튼 이 셰이더에서 정점들에 대해 각각 개별적인 조명 연산을 진행하며, 정점 정보들을 살짝 바꿔주는 등의 수정이 가능합니다. Vertex shader는 입력받은 개수만큼의 정점을 출력하며 정점의 추가 및 삭제는 불가능합니다.

Rasterizer는 말 그대로 래스터화를 진행하는데, Vertex shader에서 (물론 중간에 추가적인 셰이더가 추가될 경우 그 셰이더에서) 입력받은 정점들과 기본 도형의 정보를 가지고(대부분의 경우 삼각형입니다) **래스터화를 수행**하며, 삼각형 내부 **픽셀들을 무게중심좌표를 통해 보간**해서 채웁니다. 다음은 Direct3D 11 공식 문서에서 가져온 이미지인데 삼각형의 래스터화 방식을 설명하고 있네요.

![Untitled](https://user-images.githubusercontent.com/90246317/176607908-1a8180f4-caf8-470c-9849-29fe64ae2454.png){: .align-center}

그 다음으로 Pixel(Fragment) shader에서는 Rasterizer에서 결정된 **픽셀들의 최종 색상을 결정**합니다. 텍스처로부터 해당 픽셀의 색상값을 추출하거나 뭐 다른 로직을 사용해서 원하는 색상을 지정한다든가 할 수 있겠죠. Fragment shader는 각 픽셀의 최종 색상을 결정하고 이를 출력합니다.

마지막으로 Output merge(OM)은 정점들의 앞뒤를 따져서(두 물체가 겹쳐져 있다면 더 앞에 있는 물체를 그려야 할 테니까요. 깊이/스텐실 버퍼가 사용되는데 이 역시 자세한 설명은 생략합니다) 최종적으로 그려질 픽셀의 색을 결정하고 렌더링 대상에 출력합니다. 

제가 설명한 렌더링 파이프라인은 기초적인 뼈대만 가져와서 간소화한 것이며 애니메이션, 테셀레이션(Tessellation, 생략가능), 지오메트리 셰이더(Geometry shader, 생략가능), 클리핑(Clipping), 백페이스 컬링(Back-face culling), 뷰포트 변환(Viewport transform) 등 다른 절차들에 대한 설명은 생략했습니다. 핵심은 아주아주 기초적인 렌더링 파이프라인은 **정점 변환 및 처리(Vertex shader) → 래스터화(Rasterizer) → 픽셀 색상 최종 결정(Pixel/Fragment shader)**로 정리될 수 있다는 것입니다.

<br/><br/>

## 출처 및 참고자료

- 이득우의 게임수학
- [Rasterization Rules - Win32 apps : Microsoft Docs](https://docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules)
- [Graphics pipeline - Wikipedia](https://en.wikipedia.org/wiki/Graphics_pipeline)